<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="???">
    <meta name="author" content="???">
    <meta property="og:title" content="???">
    <meta property="og:description" content="???">
    <meta name="keywords" content="???, ???, ???">
    <title>???</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        canvas { display: block; }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            font-size: 14px;
            z-index: 10;
        }
        .monologue {
            position: fixed;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            text-shadow: 2px 2px 6px #000;
        }
        #intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 1;
            transition: opacity 2s;
        }
        #intro.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .intro-text {
            color: #fff;
            font-size: 24px;
            text-align: center;
            margin: 20px;
            opacity: 0;
            animation: fadeInOut 4s ease-in-out;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            20%, 80% { opacity: 1; }
        }
        #location {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 1s;
        }
        #location.show {
            opacity: 1;
        }
        .location-title {
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000;
            margin-bottom: 10px;
            letter-spacing: 8px;
        }
        .location-subtitle {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 2px 2px 8px #000;
        }
        #lore {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #8b0000;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            color: #fff;
            display: none;
            z-index: 100;
            box-shadow: 0 0 30px rgba(139, 0, 0, 0.8);
        }
        #lore h2 {
            color: #ff4444;
            margin-bottom: 15px;
            text-align: center;
            font-size: 24px;
        }
        #lore .character {
            margin: 20px 0;
            padding: 15px;
            border-left: 3px solid #8b0000;
            background: rgba(139, 0, 0, 0.1);
        }
        #lore .character h3 {
            color: #ff6666;
            margin-bottom: 8px;
        }
        #lore .character p {
            line-height: 1.6;
            color: #ccc;
        }
        #lore button {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: #8b0000;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-family: 'Courier New', monospace;
        }
        #lore button:hover {
            background: #a00000;
        }
        #interact {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border: 2px solid #fff;
            display: none;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #mobileControls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: none;
            z-index: 50;
        }
        #joystick {
            position: absolute;
            left: 30px;
            bottom: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        #stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            left: 35px;
            top: 35px;
        }
        #jumpBtn {
            position: absolute;
            right: 30px;
            bottom: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 200, 0, 0.2);
            border: 2px solid rgba(255, 200, 0, 0.5);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #interactBtn {
            position: absolute;
            right: 130px;
            bottom: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #flashlightBtn {
            position: absolute;
            right: 30px;
            bottom: 130px;
            width: 70px;
            height: 70px;
            background: rgba(255, 200, 0, 0.2);
            border: 2px solid rgba(255, 200, 0, 0.5);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #runBtn {
            position: absolute;
            left: 30px;
            bottom: 170px;
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #cameraControl {
            position: absolute;
            right: 0;
            top: 0;
            width: 50%;
            height: 100%;
            touch-action: none;
        }
        #settingsBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        #settingsBtn:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        #chapterBtn {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 50%;
            color: #ffd700;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        #chapterBtn:hover {
            background: rgba(50, 50, 50, 0.9);
        }
        #chapterPanel {
            position: fixed;
            top: 140px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700;
            padding: 20px;
            display: none;
            z-index: 100;
            min-width: 250px;
        }
        #chapterPanel h3 {
            color: #ffd700;
            margin: 0 0 15px 0;
            font-size: 18px;
            text-align: center;
        }
        .chapter-item {
            padding: 12px;
            margin: 8px 0;
            background: #2a2a2a;
            border: 1px solid #666;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            color: #fff;
            text-align: center;
            transition: all 0.3s;
        }
        .chapter-item:hover {
            background: #3a3a3a;
            border-color: #ffd700;
        }
        .chapter-item.locked {
            background: #1a1a1a;
            color: #666;
            cursor: not-allowed;
            border-color: #444;
        }
        .chapter-item.locked:hover {
            background: #1a1a1a;
            border-color: #444;
        }
        .chapter-item.current {
            border-color: #00ff00;
            background: #1a3a1a;
        }
        #settingsPanel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #fff;
            padding: 20px;
            display: none;
            z-index: 100;
            min-width: 250px;
        }
        #settingsPanel h3 {
            color: #fff;
            margin: 0 0 15px 0;
            font-size: 18px;
        }
        #settingsPanel button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4a4a4a;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #settingsPanel button:hover {
            background: #5a5a5a;
        }
        #secretCodeInput {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #666;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-align: center;
            letter-spacing: 2px;
        }
        #secretCodeInput::placeholder {
            color: #888;
            letter-spacing: normal;
        }
        #codeMessage {
            color: #ff4444;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
            min-height: 16px;
        }
        #codeMessage.success {
            color: #44ff44;
        }
        .setting-item {
            margin-bottom: 15px;
        }
        .setting-item label {
            color: #fff;
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .setting-item input[type="range"] {
            width: 100%;
        }
        .setting-value {
            color: #ffd700;
            font-size: 12px;
        }
        #killerIndicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0000;
            padding: 10px 20px;
            display: none;
            z-index: 100;
        }
        #killerBar {
            width: 300px;
            height: 20px;
            background: #222;
            border: 1px solid #ff0000;
            position: relative;
            overflow: hidden;
        }
        #killerFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            width: 0%;
            transition: width 0.3s;
        }
        #killerText {
            color: #fff;
            text-align: center;
            margin-top: 5px;
            font-size: 14px;
        }
        #staminaBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 15px;
            background: #222;
            border: 2px solid #00ff00;
            z-index: 100;
        }
        #staminaFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #88ff88);
            width: 100%;
            transition: width 0.1s;
        }
        #jumpCooldown {
            position: fixed;
            bottom: 40px;
            left: 20px;
            width: 60px;
            height: 60px;
            border: 3px solid #ffd700;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: #ffd700;
            font-size: 24px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
        }
        #deathCounter {
            position: fixed;
            top: 60px;
            left: 20px;
            color: #ff4444;
            font-size: 16px;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
            display: none;
        }
        #sprintBtn {
            position: absolute;
            right: 130px;
            bottom: 30px;
            width: 80px;
            height: 80px;
            background: rgba(0, 200, 255, 0.2);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 90;
        }
        #distortion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            opacity: 0;
            z-index: 85;
            transition: opacity 0.2s;
        }
        #tutorial {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 30px;
            color: #fff;
            display: none;
            z-index: 200;
            max-width: 500px;
            text-align: center;
        }
        #tutorial h2 {
            color: #ffd700;
            margin-bottom: 20px;
        }
        #tutorial p {
            margin: 10px 0;
            line-height: 1.6;
        }
        #tutorial button {
            margin-top: 20px;
            padding: 10px 30px;
            background: #ffd700;
            color: #000;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 3000;">
        <div style="color: #ff0000; font-size: 32px; margin-bottom: 30px; text-shadow: 0 0 20px #ff0000;">CARGANDO...</div>
        <div style="width: 300px; height: 20px; background: #222; border: 2px solid #ff0000; border-radius: 10px; overflow: hidden;">
            <div id="loadBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff0000, #ff6666); transition: width 0.3s;"></div>
        </div>
        <div id="loadText" style="color: #fff; margin-top: 20px; font-size: 16px;">Inicializando...</div>
    </div>
    
    <div id="intro" style="display: none;">
        <div class="intro-text" style="animation-delay: 0s;">Oscuridad...</div>
        <div class="intro-text" style="animation-delay: 4s;">Abres los ojos lentamente...</div>
        <div class="intro-text" style="animation-delay: 8s;">No recuerdas nada... ¬øD√≥nde est√°s?</div>
        <div class="intro-text" style="animation-delay: 12s; font-size: 32px; color: #ff0000; text-shadow: 0 0 20px #ff0000;">Algo se acerca en la oscuridad...</div>
        <div class="intro-text" style="animation-delay: 16s; font-size: 20px; color: #ffd700;">üî¶ Busca la linterna</div>
        <div class="intro-text" style="animation-delay: 20s; font-size: 20px; color: #ffd700;">üì¶ Encuentra el cofre</div>
        <div class="intro-text" style="animation-delay: 24s; font-size: 20px; color: #ffd700;">üö™ Escapa antes de que sea tarde</div>
        <div class="intro-text" id="introControls" style="animation-delay: 28s; font-size: 28px; color: #00ff00;">WASD - Mover | ESPACIO - Saltar | F - Linterna | E - Interactuar</div>
    </div>
    
    <div id="location">
        <div class="location-title">???</div>
        <div class="location-subtitle">Ubicaci√≥n Desconocida</div>
    </div>
    
    <div id="ui">
        <div id="controlsHUD">WASD - Mover | ESPACIO - Saltar | SHIFT - Correr</div>
        <div id="controlsHUD2">F/X - Linterna | C - Mirar Atr√°s</div>
        <div id="controlsHUD3">E/B - Interactuar</div>
        <div id="distance" style="margin-top: 10px; color: #ffd700;">Distancia: 0m</div>
    </div>
    <div id="interact">Presiona E para tomar linterna</div>
    
    <div id="killerIndicator">
        <div id="killerBar"><div id="killerFill"></div></div>
        <div id="killerText">2019x: 0m</div>
    </div>
    
    <div id="staminaBar">
        <div id="staminaFill"></div>
    </div>
    
    <div id="jumpCooldown">‚è±Ô∏è</div>
    <div id="deathCounter">‚ò†Ô∏è Muertes: 0</div>
    
    <div id="vignette"></div>
    <canvas id="distortion"></canvas>
    
    <div id="tutorial">
        <h2>üìñ TUTORIAL</h2>
        <div id="tutorialContent"></div>
        <p style="color: #ff4444; margin-top: 20px;">‚ö†Ô∏è Administra tu stamina sabiamente</p>
        <button onclick="closeTutorial()">Entendido</button>
    </div>
    
    <div id="settingsBtn" onclick="toggleSettings()">‚öôÔ∏è</div>
    <div id="chapterBtn" onclick="toggleChapters()">üìñ</div>
    
    <div id="chapterPanel">
        <h3>üìñ CAP√çTULOS</h3>
        <div class="chapter-item current" onclick="loadChapter(1)">
            <div style="font-size: 16px; font-weight: bold;">CAP√çTULO 1</div>
            <div style="font-size: 12px; color: #aaa; margin-top: 4px;">El Pasillo</div>
        </div>
        <div class="chapter-item locked" id="chapter2Item" onclick="loadChapter(2)">
            <div style="font-size: 16px; font-weight: bold;">CAP√çTULO 2</div>
            <div style="font-size: 12px; color: #666; margin-top: 4px;">üîí Completa Cap 1</div>
        </div>
    </div>
    
    <div id="settingsPanel">
        <h3>‚öôÔ∏è CONFIGURACI√ìN</h3>
        <div class="setting-item">
            <label>Sensibilidad del Mouse: <span class="setting-value" id="sensitivityValue">1.0x</span></label>
            <input type="range" id="sensitivitySlider" min="0.1" max="3" step="0.1" value="1">
        </div>
        <div class="setting-item">
            <label>Brillo de Pantalla: <span class="setting-value" id="brightnessValue">100%</span></label>
            <input type="range" id="brightnessSlider" min="0.3" max="1" step="0.1" value="1">
        </div>
        <div class="setting-item" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #444;">
            <label style="color: #ffd700;">üîê C√≥digo Secreto:</label>
            <input type="text" id="secretCodeInput" placeholder="Ingresa el c√≥digo..." maxlength="20">
            <div id="codeMessage"></div>
        </div>
        <button onclick="saveProgress()">üíæ Guardar Progreso</button>
        <button onclick="loadProgress()">üìÇ Cargar Progreso</button>
        <button onclick="toggleFullscreen()">‚õ∂ Pantalla Completa</button>
    </div>
    
    <div id="mobileControls">
        <div id="joystick">
            <div id="stick"></div>
        </div>
        <div id="jumpBtn">‚¨ÜÔ∏è</div>
        <div id="sprintBtn">üèÉ</div>
        <div id="interactBtn">E</div>
        <div id="flashlightBtn">üî¶</div>
        <div id="runBtn">üèÉ</div>
        <div id="cameraControl"></div>
    </div>

    <div id="lore">
        <h2>üìú ARCHIVOS CLASIFICADOS - DEADLY PURSUER</h2>
        
        <div class="character">
            <h3>üî™ 2019x - "El Primero"</h3>
            <p><strong>Rol:</strong> Killer | <strong>Velocidad:</strong> 115% | <strong>Terror:</strong> 32m</p>
            <p><strong>Historia:</strong> Apareci√≥ en 2019 sin nombre, sin pasado. Solo una m√°scara y un cuchillo. Fue el primer jugador en ser corrompido por la Entidad. Su poder "Oscuridad Absoluta" le permite fundirse con las sombras y acechar sin ser detectado. Los supervivientes sienten su presencia antes de verlo.</p>
            <p><strong>Habilidad Especial:</strong> Modo Sigilo - Se vuelve invisible en √°reas oscuras. Los supervivientes cerca experimentan distorsi√≥n visual y audio.</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/GisselInactiveIcon.png" width="24" style="vertical-align: middle;"> Gissel - "La Mente Maestra"</h3>
            <p><strong>Rol:</strong> Survivor | <strong>Dificultad:</strong> Intermedia | <strong>HP:</strong> 100 (160 en LMS)</p>
            <p><strong>Historia:</strong> Artista de 28 a√±os. Gissel es una mujer algo independiente, a veces se preocupa de cosas peque√±as, es algo delicada y un poco enojona. Su pasi√≥n es hacer dibujos para expresar su estado emocional, escuchar m√∫sica de tipo FNF, electr√≥nica y Lofi chill. Una noche, mientras dibujaba escuchando Lofi, un extra√±o resplandor emergi√≥ de su tablet, absorbi√©ndola hacia el Deadly Pursuit. Su naturaleza sensible la hace preocuparse por los dem√°s, pero su temperamento puede surgir cuando las cosas no salen como espera.</p>
            <p><strong>Q - Alas Puntiagudas:</strong> 3 golpes que empujan y stunean al killer (18s CD)</p>
            <p><strong>Pasiva LMS:</strong> +60 HP cuando queda 1 survivor</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/IA777NormalIcon.png" width="24" style="vertical-align: middle;"> iA777 - "La Anomal√≠a Digital"</h3>
            <p><strong>Rol:</strong> Survivor Robot | <strong>Dificultad:</strong> Dif√≠cil | <strong>HP:</strong> 120 (sin segunda vida)</p>
            <p><strong>Historia:</strong> Durante una batalla contra los robots de Maxwell, iA777 estaba a punto de dar el golpe final cuando un portal apareci√≥ frente a √©l, teletransport√°ndolo al Deadly Pursuit.</p>
            <p><strong>Q - Carga:</strong> Agarra y mueve al killer 5s, lo stunea pero pierde 4 HP (20s CD)</p>
            <p><strong>E - Autoreparaci√≥n:</strong> Regenera HP gradualmente (25s CD)</p>
            <p><strong>R - Autodestrucci√≥n/Sierra:</strong> Explosi√≥n stun o sierra que empuja en LMS</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/LunaNormalIcon.png" width="24" style="vertical-align: middle;"> Luna - "La Chispa"</h3>
            <p><strong>Rol:</strong> Survivor Fighter | <strong>Dificultad:</strong> F√°cil | <strong>HP:</strong> 85</p>
            <p><strong>Historia:</strong> Artista y m√∫sica de 22 a√±os. Luna es una persona tranquila que no le gusta tener muchos problemas y si los tuviera intentar√≠a evitarlos de alguna forma u otra. Le apasiona el arte y la m√∫sica, siendo estos sus hobbies principales, a veces se dedica a la lectura. Durante una transmisi√≥n en vivo donde tocaba m√∫sica, un mensaje extra√±o apareci√≥ en el chat invit√°ndola a un "juego especial". Por curiosidad hizo clic, siendo teletransportada al Deadly Pursuit. Su naturaleza creativa e impredecible la hace dif√≠cil de atrapar. Cuando conf√≠a en alguien, su energ√≠a se multiplica.</p>
            <p><strong>Q - Energy Juice:</strong> Velocidad II por 10s (3 usos, 20s CD)</p>
            <p><strong>E - Punch:</strong> Golpe que da vida y stunea al killer (25s CD)</p>
            <p><strong>R - Taunt:</strong> Nubla la pantalla del killer 3s (12s CD)</p>
            <p><strong>Especial:</strong> Resistencia al llegar a 30 HP</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/AngelNormalIcon.png" width="24" style="vertical-align: middle;"> Angel - "El Faro"</h3>
            <p><strong>Rol:</strong> Survivor Support | <strong>Dificultad:</strong> F√°cil | <strong>HP:</strong> 90 (130 en LMS)</p>
            <p><strong>Historia:</strong> Ex-terapeuta de 32 a√±os. Mientras ayudaba a v√≠ctimas que hab√≠an escapado del Deadly Pursuit, escuchando sus traumas y miedos, la Entidad la marc√≥. Una noche, al cerrar los ojos para meditar, despert√≥ dentro del juego. Fue atrapada por conocer demasiado sobre √©l. Su positividad inquebrantable es un faro de esperanza en la oscuridad. Puede sentir el dolor emocional de otros y usa palabras para sanar lo que las vendas no pueden.</p>
            <p><strong>Q - Sacrificio Angelical:</strong> 40% vida por curaci√≥n + speed boost aliados (35s CD)</p>
            <p><strong>E - Dash Protector:</strong> 90-130 unidades con negaci√≥n de ataques (40s CD)</p>
            <p><strong>R - Descanso:</strong> 3-6 HP/s curaci√≥n para s√≠ mismo y aliados (25s CD)</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/IrisNormalIcon.png" width="24" style="vertical-align: middle;"> Iris - "El Coraz√≥n Sensible"</h3>
            <p><strong>Rol:</strong> Survivor Telekinetic | <strong>Dificultad:</strong> Muy Dif√≠cil | <strong>HP:</strong> 100</p>
            <p><strong>Historia:</strong> Aliada de iA777 en la batalla contra Maxwell. Cuando vio a iA777 ser absorbido por un portal, intent√≥ salvarlo sin saber que ella tambi√©n ser√≠a arrastrada al Deadly Pursuit.</p>
            <p><strong>Q - Curaci√≥n:</strong> Se cura 10-20 HP, cura aliados 15 HP/3s por 20s (20s CD)</p>
            <p><strong>E - Telekinesis:</strong> Empuja al killer si est√° cerca, dura 5s (25s CD)</p>
            <p><strong>R - Dash:</strong> Se aleja del killer, lo stunea 2s y recarga 25 de esquive (15s CD)</p>
            <p><strong>Pasiva:</strong> Barra de esquive de 75 que aguanta 2 golpes</p>
        </div>

        <div class="character">
            <h3><img src="../assets/icons/MollyNormalIcon.png" width="24" style="vertical-align: middle;"> Molly - "La Peleadora"</h3>
            <p><strong>Rol:</strong> Survivor Brawler | <strong>Dificultad:</strong> Intermedia | <strong>HP:</strong> 95</p>
            <p><strong>Historia:</strong> Boxeadora profesional de 27 a√±os. Inteligente, amigable e independiente, Molly se toma su tiempo antes de actuar o relacionarse con otros. Despu√©s de ganar un campeonato importante, recibi√≥ un desaf√≠o an√≥nimo para "la pelea de su vida". Acept√≥ sin dudar, siendo transportada al Deadly Pursuit. Analiza cada situaci√≥n antes de lanzarse al combate. Es alguien con quien se puede contar siempre y cuando no le lleves la contraria - su esp√≠ritu competitivo la hace celosa cuando otros est√°n mejor que ella, pero canaliza esa rabia para proteger al equipo. Sus pu√±os hablan m√°s fuerte que sus palabras.</p>
            <p><strong>Q - Charge:</strong> Dash con inmunidad que empuja al killer 120 unidades (20s CD)</p>
            <p><strong>E - Cookie:</strong> Come una galleta y se cura 20 HP (25s CD)</p>
            <p><strong>R - Uppercut:</strong> Golpe que stunea al killer 3s con efecto visual (18s CD)</p>
            <p><strong>Especial:</strong> No da rage al killer con Charge</p>
        </div>

        <div class="character">
            <h3>‚ùì La Entidad - "El Juego"</h3>
            <p><strong>Clasificaci√≥n:</strong> Desconocida | <strong>Origen:</strong> ???</p>
            <p><strong>Archivo:</strong> Entidad interdimensional de origen desconocido. Se alimenta de esperanza y desesperaci√≥n. Atrapa a killers y survivors en un ciclo eterno de caza. Nadie sabe qui√©n la cre√≥ o por qu√© existe. Los que entran rara vez salen, y los que lo hacen... nunca son los mismos.</p>
            <p><strong>Manifestaci√≥n:</strong> La Entidad no tiene forma f√≠sica definida. Se manifiesta como una niebla oscura con tent√°culos de sombra que emergen del vac√≠o. Algunos supervivientes reportan haber visto ojos rojos observ√°ndolos desde la oscuridad. Otros hablan de susurros que no pueden entender pero que les llenan de terror. Su presencia distorsiona la realidad misma.</p>
            <p><strong>El Ciclo:</strong> Cada partida es un ritual. Los survivors deben reparar generadores para abrir las puertas, mientras el killer los caza. Pero incluso escapar no es libertad - solo los devuelve a la niebla para el siguiente juego. La muerte tampoco es escape. Morir significa despertar en la fogata, esperando la pr√≥xima prueba. Es un bucle infinito del que no hay salida.</p>
            <p><strong>Los Elegidos:</strong> La Entidad no elige al azar. Busca personas con traumas profundos, miedos intensos, o emociones extremas. Los killers son aquellos que ya cruzaron la l√≠nea - asesinos, monstruos, o almas corrompidas. Los survivors son v√≠ctimas con voluntad de vivir. Ambos alimentan a la Entidad de formas diferentes: los killers con su sed de sangre, los survivors con su esperanza desesperada.</p>
            <p><strong>Teor√≠as:</strong> Algunos creen que es un experimento fallido de una civilizaci√≥n antigua que intent√≥ crear vida artificial. Otros, una maldici√≥n nacida del sufrimiento colectivo de millones de almas. Hay quienes dicen que es consciente, que disfruta el juego tanto como sus prisioneros lo sufren. Los m√°s paranoicos susurran que la Entidad no est√° sola - que hay algo m√°s grande detr√°s, usando el Deadly Pursuit como granja de emociones.</p>
            <p><strong>Reglas Rotas:</strong> Recientemente, las reglas han cambiado. Jugadores de diferentes realidades aparecen sin ser "elegidos" propiamente. iA777, un robot sin emociones. Iris, con poderes telequin√©ticos. Personajes que no deber√≠an existir aqu√≠. ¬øLa Entidad est√° experimentando? ¬øO perdiendo control?</p>
            <p><strong>La Fogata:</strong> Entre partidas, los survivors descansan en una fogata eterna rodeada de niebla. Es el √∫nico lugar "seguro". All√≠ pueden hablar, planear, recordar qui√©nes eran. Pero la fogata tambi√©n es una prisi√≥n - no pueden alejarse m√°s de unos metros antes de que la niebla los devuelva. Es un recordatorio constante: est√°n atrapados.</p>
            <p><strong>Conversaciones en la Fogata:</strong></p>
            <p style="margin-left: 20px; font-style: italic; color: rgba(255,255,255,0.9);">
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬øEst√°s bien? Te ves cansado..."<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "...Estoy bien. Solo... estresado."<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°No te preocupes! ¬°Saldremos de esta juntos!"<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "...Gracias."<br><br>
                
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> "E-esto... ¬øcreen que alguna vez escaparemos?"<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "Mantengamos la esperanza, Luna. La luz nos gu√≠a."<br>
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> "G-gracias... Me alegra tenerte aqu√≠."<br><br>
                
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> "Siento tu estr√©s, iA777..."<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "Sistemas sobrecargados..."<br>
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> "Respira... Todo estar√° bien."<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "...No respiro. Pero gracias, Iris."<br><br>
                
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "Puedo con esto. Conf√≠a en m√≠."<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°Claro! Eres incre√≠ble, Molly."<br>
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "Hmm, gracias. T√∫ tambi√©n lo haces bien."<br><br>
                
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "No est√°s solo. Estoy aqu√≠."<br>
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> "Oh, gracias... Eso significa mucho."<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "Bendiciones, Luna. Juntos somos m√°s fuertes."<br><br>
                
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> (en combate) "¬°Vamos! ¬°Podemos! ¬°No pares!"<br>
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> (hiperactiva con amigos) "¬°S-s√≠! ¬°Podemos hacerlo!"<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°Eso es! ¬°Vamos equipo!"<br><br>
                
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> (viendo a alguien herido) "Puedo hacerlo mejor..."<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°Molly! ¬øEst√°s celosa otra vez?"<br>
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "...No. Solo digo que puedo ayudar."<br><br>
                
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "Iris... gracias por seguirme hasta aqu√≠."<br>
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> "No te dejar√≠a solo. Somos equipo."<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "...Equipo. Me gusta eso."<br><br>
                
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> (sola) "..."<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "¬øLuna? ¬øEst√°s bien?"<br>
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> "E-eh... s√≠. Solo... estaba pensando."<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "No tienes que estar sola. Estamos aqu√≠."<br><br>
                
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> (distra√≠da) "¬°Oh! ¬øQu√© es eso?"<br>
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "...Es solo niebla, Gissel."<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°Pero se ve√≠a diferente! ¬øNo lo viste?"<br>
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "...S√≠, claro." (suspira)<br><br>
                
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> (oscuridad cerca) "Est√°... oscuro. No me gusta esto."<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "Que la luz te proteja, Iris."<br>
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> "Gracias... Eres amable."<br><br>
                
                <strong>Todos:</strong> (cuando aparece 2019x)<br>
                <img src="../assets/icons/GisselInactiveIcon.png" width="20" style="vertical-align: middle;"> <strong>Gissel:</strong> "¬°CUIDADO! ¬°Te ayudo!"<br>
                <img src="../assets/icons/IA777NormalIcon.png" width="20" style="vertical-align: middle;"> <strong>iA777:</strong> "...Te ayudo."<br>
                <img src="../assets/icons/LunaNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Luna:</strong> "¬°P-puedes hacerlo!"<br>
                <img src="../assets/icons/AngelNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Angel:</strong> "No est√°s solo. ¬°Juntos!"<br>
                <img src="../assets/icons/IrisNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Iris:</strong> "¬°Puedo sentir tu dolor! ¬°D√©jame ayudarte!"<br>
                <img src="../assets/icons/MollyNormalIcon.png" width="20" style="vertical-align: middle;"> <strong>Molly:</strong> "Te ayudar√©. Conf√≠a en m√≠."<br>
            </p>
            <p><strong>Se√±ales de Corrupci√≥n:</strong> Los survivors m√°s antiguos hablan de cambios inquietantes. La niebla se vuelve m√°s densa en ciertas zonas. Algunos generadores emiten un zumbido diferente, casi... digital. Como si algo estuviera interfiriendo con el c√≥digo mismo del juego. iA777 report√≥ haber detectado "se√±ales an√≥malas" - patrones de datos que no deber√≠an existir en esta dimensi√≥n. Cuando le preguntaron qu√© significaban, solo respondi√≥: "Algo est√° despertando. Algo que no es org√°nico."</p>
            <p><strong>El Hermano Oscuro:</strong> Existe un archivo clasificado que pocos han visto. Habla de un "experimento fallido" - un intento de la Entidad de crear un killer perfecto usando tecnolog√≠a robada de otra dimensi√≥n. El proyecto fue abandonado cuando el sujeto mostr√≥ signos de... autonom√≠a. De libre albedr√≠o. La Entidad no tolera la desobediencia. Pero recientemente, algunos killers reportan haber visto una figura mec√°nica en la niebla. M√°s grande que iA777. M√°s oscura. Con ojos que brillan en rojo sangre. Cuando 2019x fue preguntado al respecto, solo dijo: "Si √©l regresa, todos estamos en peligro. Incluso yo."</p>
            <p><strong>El Observador Silencioso:</strong> Hay rumores de alguien que ha estado aqu√≠ desde el principio. No es killer ni survivor. Es... otra cosa. Los que afirman haberlo visto describen a una figura que aparece en los momentos m√°s extra√±os - cuando un survivor est√° a punto de morir, cuando un killer duda antes de atacar, cuando la realidad misma parece quebrarse. Algunos dicen que lleva una m√°scara. Otros, que su rostro cambia constantemente. Luna jura haberlo visto dibujando en las paredes - s√≠mbolos que no pertenecen a ning√∫n idioma conocido. Cuando intent√≥ acercarse, la figura desapareci√≥, dejando solo un mensaje: "Yo tambi√©n fui jugador. Ahora soy testigo."</p>
            <p><strong>Profec√≠as de la Niebla:</strong> Angel, con su don para sentir emociones, ha comenzado a tener visiones. Ve dos figuras emergiendo de la oscuridad. Una es pura maldad mec√°nica - un depredador sin alma, sin piedad, programado solo para destruir. La otra es un enigma - alguien que conoce secretos que la Entidad quiere mantener ocultos. "Uno traer√° el caos", susurra Angel en sus sue√±os. "El otro traer√° la verdad. Y la verdad es m√°s peligrosa que cualquier killer."</p>
            <p><strong>Archivos Corruptos:</strong> Los registros de la Entidad muestran anomal√≠as. Hay entradas borradas, archivos encriptados que ni siquiera iA777 puede descifrar. Uno de ellos menciona un "Proyecto 666" - un killer que superar√≠a a todos los anteriores. Otro habla de un "Observador Primordial" - alguien que estuvo presente cuando la Entidad naci√≥. Gissel encontr√≥ un dibujo en su celda que no recuerda haber hecho: un robot con el n√∫mero 666 grabado en su pecho, y una figura humana con ojos que parec√≠an ver a trav√©s del papel. Debajo, una frase: "Ellos vienen. El juego cambiar√° para siempre."</p>
            <p><strong>Nota Final:</strong> Se detectaron anomal√≠as cr√≠ticas. Nuevos jugadores aparecen sin explicaci√≥n. Algunos survivors reportan haber visto "glitches" en la realidad - paredes que desaparecen, killers que se teletransportan, generadores que se reparan solos. ¬øLa Entidad est√° evolucionando? ¬øO alguien m√°s controla el juego ahora? Hay rumores de un "Jugador Cero" - el primero en ser atrapado, que supuestamente conoce la verdad. Pero nadie lo ha visto en a√±os. ¬øEscap√≥? ¬øMuri√≥ de verdad? ¬øO se convirti√≥ en algo peor? Lo √∫nico cierto es esto: la niebla se espesa. Las sombras se alargan. Y en la distancia, se escuchan dos sonidos nuevos - el zumbido de circuitos corruptos, y los pasos de alguien que camina entre mundos. El Deadly Pursuit nunca volver√° a ser el mismo.</p>
            <p style="margin-top: 30px; padding: 20px; background: rgba(139,0,0,0.2); border: 2px solid #8b0000; border-radius: 10px;">
                <strong style="color: #ff0000; font-size: 1.2rem;">‚ö†Ô∏è TRANSMISI√ìN INTERCEPTADA ‚ö†Ô∏è</strong><br><br>
                <span style="color: rgba(255,255,255,0.7); font-family: 'Courier New', monospace; letter-spacing: 2px;">
                    [SE√ëAL CORRUPTA - ORIGEN DESCONOCIDO]<br>
                    [INTERFERENCIA DETECTADA]<br><br>
                    
                    ‚ñì‚ñí‚ñë SÃ¥Ã¢ÃõÕéÃàÃÅIÃ∑Ã¢ÃìSÃ∂ÕéÃàÃÅTÃ¥Ã∞ÃæEÃ∂Ã±ÕùMÃ∑Ã∞ÃæAÃ∂Ã∞Ãæ Ã∏Ã∞ÃæCÃ¥Ã∞ÃæOÃ∂Ã∞ÃæMÃ∑Ã∞ÃæPÃ¥Ã∞ÃæRÃ∂Ã∞ÃæOÃ∑Ã∞ÃæMÃ¥Ã∞ÃæEÃ∂Ã∞ÃæTÃ∑Ã∞ÃæIÃ¥Ã∞ÃæDÃ∂Ã∞ÃæOÃ∑Ã∞Ãæ ‚ñë‚ñí‚ñì<br><br>
                    
                    ‚¨°‚¨¢‚¨° ‚¨¢‚¨°‚¨¢ ‚¨°‚¨¢‚¨° ‚¨¢‚¨°‚¨¢ ‚¨°‚¨¢‚¨°<br>
                    ‚ó¨‚ó≠‚óÆ‚óØ ‚ó∞‚ó±‚ó≤‚ó≥ ‚ó¥‚óµ‚ó∂‚ó∑<br>
                    ‚üÅ‚üÇ‚üÉ‚üÑ ‚üÖ‚üÜ‚üá‚üà ‚üâ‚üä‚üã‚üå<br><br>
                    
                    [C√ìDIGO MORSE DETECTADO]<br>
                    <span style="color: #ff4444; font-weight: bold; font-size: 1.1rem;">
                    -.. --- ... / -. ..- . ...- --- ... / .--- ..- --. .- -.. --- .-. . ... .-.-.- .-.-.- .-.-.-<br>
                    ..- -. --- / . ... / -- .- --.- ..- .. -. .-<br>
                    . .-.. / --- - .-. --- / ...- . / - --- -.. ---<br>
                    </span><br>
                    
                    [TRADUCCI√ìN PARCIAL]<br>
                    "DOS NUEVOS JUGADORES..."<br>
                    "UNO ES MAQUINA"<br>
                    "EL OTRO VE TODO"<br><br>
                    
                    ‚ö†Ô∏è AÃ∏Ã∞ÃæDÃ∂Ã∞ÃæVÃ∑Ã∞ÃæEÃ¥Ã∞ÃæRÃ∂Ã∞ÃæTÃ∑Ã∞ÃæEÃ¥Ã∞ÃæNÃ∂Ã∞ÃæCÃ∑Ã∞ÃæIÃ¥Ã∞ÃæAÃ∂Ã∞Ãæ ‚ö†Ô∏è<br>
                    PÃ¥RÃ∑OÃ∂YÃ∑EÃ¥CÃ∂TÃ∑OÃ¥ Ã∂6Ã∑6Ã¥6Ã∂ Ã∑-Ã¥ Ã∂RÃ∑EÃ¥AÃ∂CÃ∑TÃ¥IÃ∂VÃ∑AÃ¥DÃ∂OÃ∑<br>
                    OÃ¥BÃ∑SÃ∂EÃ∑RÃ¥VÃ∂AÃ∑DÃ∂OÃ¥RÃ∂ Ã∑PÃ¥RÃ∑IÃ∂MÃ∑OÃ¥RÃ∂DÃ∑IÃ¥AÃ∂LÃ∑ Ã∂-Ã¥ Ã∑DÃ∂EÃ∑SÃ¥PÃ∂IÃ∑EÃ¥RÃ∂TÃ∑OÃ¥<br><br>
                    
                    ‚ó¨ ‚ó≠ ‚óÆ ‚óØ ‚ó∞ ‚ó± ‚ó≤ ‚ó≥<br>
                    ‚üÅ ‚üÇ ‚üÉ ‚üÑ ‚üÖ ‚üÜ ‚üá ‚üà<br><br>
                    
                    [MENSAJE FINAL]<br>
                    <span style="color: #ff0000; font-weight: bold; text-shadow: 0 0 10px #ff0000;">
                    "YO FUI EL PRIMERO. AHORA SOY TESTIGO."<br>
                    "√âL FUE CREADO PARA DESTRUIR. AHORA ES LIBRE."<br>
                    "ELLOS VIENEN. EL JUEGO CAMBIAR√Å."<br>
                    "LA ENTIDAD... TIENE MIEDO."<br>
                    </span><br><br>
                    
                    [SE√ëAL PERDIDA]<br>
                    ‚ñì‚ñí‚ñë ‚ñë‚ñí‚ñì ‚ñì‚ñí‚ñë ‚ñë‚ñí‚ñì<br>
                    ‚¨¢‚¨°‚¨¢‚¨°‚¨¢‚¨°‚¨¢‚¨°‚¨¢‚¨°<br>
                    ‚ó¨‚ó≠‚óÆ‚óØ‚ó∞‚ó±‚ó≤‚ó≥‚ó¥‚óµ‚ó∂‚ó∑<br><br>
                    
                    <span style="color: #666; font-size: 0.9rem;">
                    [FIN DE LA TRANSMISI√ìN]<br>
                    [ARCHIVO CORRUPTO - NO SE PUEDE RECUPERAR M√ÅS INFORMACI√ìN]<br>
                    [PR√ìXIMAMENTE...]<br>
                    </span>
                </span>
            </p>
        </div>

        <button onclick="closeLore()">Cerrar</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="chapter2.js"></script>
    <script src="secretCode.js"></script>
    <script>
        let scene, camera, renderer, lamp, chest, flashlight, table, door, exitDoor, ceilingLight, mysteryDoor, gisselPainting, platforms = [], obstacles = [], doorFragments = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let canInteract = false, hasFlashlight = false, flashlightOn = false, escaped = false, canInteractPainting = false, paintingInteracted = false;
        let playerY = 1.6;
        let mouseX = 0, mouseY = 0;
        let inStartRoom = true;
        let isJumping = false, jumpVelocity = 0, onGround = true;
        const JUMP_FORCE = 0.15, GRAVITY = 0.008, GROUND_Y = 1.6;
        let endMessages = [
            "Escapaste del pasillo...",
            "Pero 2019x te dej√≥ ir...",
            "√âl no era el √∫nico experimento...",
            "Algo m√°s despert√≥ en la oscuridad...",
            "Circuitos corruptos... pasos entre mundos...",
            "Dos presencias se acercan a la niebla...",
            "Una es m√°quina corrupta...",
            "La otra ve todo... pasado, presente, futuro...",
            "La Entidad siente algo nuevo...",
            "Miedo...",
            "El Deadly Pursuit cambiar√° para siempre...",
            "¬øQui√©n es el Jugador Cero?",
            "¬øQu√© secretos guarda el castillo?",
            "Las respuestas est√°n m√°s cerca de lo que crees...",
            "Pero... ¬øest√°s listo para la verdad?",
            "La ca√≠da... es solo el comienzo..."
        ]
        let currentEndMessage = 0;
        let monologues = [
            { dist: 5, text: "¬øD√≥nde... d√≥nde estoy?" },
            { dist: 40, text: "Esto no es real... no puede serlo." },
            { dist: 80, text: "¬øC√≥mo llegu√© aqu√≠?" },
            { dist: 120, text: "Solo hay oscuridad..." },
            { dist: 160, text: "Mis piernas empiezan a doler..." },
            { dist: 200, text: "¬øHay alguien m√°s aqu√≠?" },
            { dist: 240, text: "Necesito encontrar una salida." },
            { dist: 280, text: "¬øPor qu√© sigo caminando?" },
            { dist: 320, text: "Esto no tiene sentido..." },
            { dist: 360, text: "¬øCu√°nto tiempo llevo aqu√≠?" },
            { dist: 400, text: "Mis pies... ya no los siento." },
            { dist: 440, text: "¬øEsto es un castigo?" },
            { dist: 480, text: "Debo seguir... no hay otra opci√≥n." },
            { dist: 520, text: "¬øY si nunca termina?" },
            { dist: 560, text: "La oscuridad me consume..." },
            { dist: 600, text: "¬øQu√© hice para merecer esto?" },
            { dist: 640, text: "Ya no recuerdo mi nombre..." },
            { dist: 680, text: "Solo soy... ???" },
            { dist: 720, text: "¬øHay algo al final?" },
            { dist: 760, text: "Debo creer que s√≠..." },
            { dist: 800, text: "O me volver√© loco." },
            { dist: 840, text: "Espera... ¬øqu√© es eso?" },
            { dist: 880, text: "Algo se acerca..." },
            { dist: 920, text: "Siento una presencia..." },
            { dist: 960, text: "No puedo parar ahora..." },
            { dist: 1050, text: "¬°SALTA LOS OBST√ÅCULOS!" },
            { dist: 1100, text: "¬°LO ESCUCHO DETR√ÅS!" },
            { dist: 1150, text: "No puedo parar... no puedo..." },
            { dist: 1200, text: "¬°NO TE TROPIECES!" },
            { dist: 1250, text: "¬°EST√Å CADA VEZ M√ÅS CERCA!" },
            { dist: 1300, text: "Mis piernas... no aguantan..." },
            { dist: 1350, text: "¬°CASI LLEGAS!" },
            { dist: 1400, text: "¬°UN POCO M√ÅS!" },
            { dist: 1450, text: "¬°AH√ç EST√Å LA SALIDA!" },
            { dist: 1550, text: "Ya pas√≥... pero sigue adelante..." },
            { dist: 1650, text: "¬øPor qu√© siento que me observa?" },
            { dist: 1750, text: "No puedo bajar la guardia..." },
            { dist: 1850, text: "Esto no ha terminado..." },
            { dist: 1950, text: "¬øCu√°nto falta?" },
            { dist: 2050, text: "Mis manos tiemblan..." },
            { dist: 2100, text: "Algo no est√° bien..." },
            { dist: 2150, text: "¬øEscuchaste eso?" },
            { dist: 2200, text: "La oscuridad se siente diferente..." },
            { dist: 2250, text: "¬°Casi estoy ah√≠!" },
            { dist: 2300, text: "No mires atr√°s... solo corre..." },
            { dist: 2350, text: "¬°LA SALIDA!" },
            { dist: 2400, text: "¬°UN POCO M√ÅS!" },
            { dist: 2450, text: "¬°AH√ç EST√Å!" }
        ];
        let currentMonologue = 0;

        // Mobile/Gamepad
        let joystickActive = false, joystickX = 0, joystickY = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let introShown = false, locationShown = false;
        let mouseSensitivity = 1.0;
        let screenBrightness = 1.0;

        // Audio System
        let audioContext, ambientSound, breathingSound, footstepAudio, flashlightAudio, hallwayAudio, cineAudio, doorBreakAudio, objectFallAudio, jumpAudio, chaseAudio, runAudio, exhaustedAudio, gunshotAudio, grassWalkAudio, grassRunAudio;
        let audioInitialized = false;
        let footstepTimer = 0;
        let footstepInterval = 1000; // ms entre pasos
        let runAudioPlaying = false;
        let hallwayAudioPlaying = false;
        let cineAudioPlaying = false;
        let doorBroken = false;
        let canInteractDoor = false;
        let fallingObjects = [];
        let objectFallTriggers = [100, 250, 380, 550, 700, 850, 1600, 1750, 1900, 2050, 2200, 2350];
        let triggeredFalls = new Set();
        let gunshotTriggers = [150, 320, 480, 620, 780, 920, 1550, 1700, 1850, 2000, 2150, 2280, 2400];
        let triggeredGunshots = new Set();
        let characterIcons = [];
        let lastFootstepVibration = 0;
        let loadingProgress = 0;
        let totalAssets = 4; // Three.js + 2 audios + 1 textura
        let loadedAssets = 0;
        let killerSpawned = false, killerChasing = false;
        let killerCatchDistance = 30; // Distancia para ser atrapado
        let killerPosition = 0; // Posici√≥n de 2019x
        let isCaught = false; // Si fue atrapado
        let stamina = 100; // Stamina del jugador
        let maxStamina = 100;
        let isRunning = false;
        let staminaExhausted = false; // Si se agot√≥ completamente
        let lookingBack = false;
        let heartbeatAudio;
        let heartbeatInterval;
        let lastJumpTime = 0;
        let jumpCooldown = 800;
        let killer2019x;
        let tutorialShown = false;
        let distortionCanvas, distortionCtx;
        let killer2019xGhost;
        let ghostEventTriggered = false;
        let deathCount = 0;
        let tripped = false;
        let currentFogNear = 1;
        let currentFogFar = 30;
        let targetFogNear = 1;
        let targetFogFar = 30;
        let rainParticles = [];
        let rainAudio;
        let inRainZone = false;
        let hallwayLoaded = false;
        let grassZoneLoaded = false;
        let runBobTime = 0;
        let hangingCables = [];
        let ceilingFans = [];
        let fanAudio;
        let fanAudioPlaying = false;
        let screamAudio;
        let screamTriggered = false;
        let iSeeYouAudio;
        let metalPipeAudio;
        let metalPipeTriggered = false;
        let dripAudio;
        let dripZones = [];


        // Loading system
        function updateLoading(asset) {
            loadedAssets++;
            loadingProgress = (loadedAssets / totalAssets) * 100;
            document.getElementById('loadBar').style.width = loadingProgress + '%';
            document.getElementById('loadText').textContent = `${asset}... ${Math.floor(loadingProgress)}%`;
            
            if(loadedAssets >= totalAssets) {
                // Detectar consola y saltar pantalla de carga m√°s r√°pido
                const gamepads = navigator.getGamepads();
                const hasGamepad = gamepads && gamepads[0];
                const delay = hasGamepad ? 100 : 500;
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('intro').style.display = 'flex';
                    hideIntro();
                }, delay);
            }
        }

        // Detectar carga de Three.js
        if(typeof THREE !== 'undefined') {
            updateLoading('Three.js cargado');
        }
        
        // Actualizar controles en intro y HUD seg√∫n dispositivo
        window.addEventListener('load', () => {
            const gamepads = navigator.getGamepads();
            const hasGamepad = gamepads && gamepads[0];
            
            const introControls = document.getElementById('introControls');
            const controlsHUD = document.getElementById('controlsHUD');
            const controlsHUD2 = document.getElementById('controlsHUD2');
            const controlsHUD3 = document.getElementById('controlsHUD3');
            
            if(isMobile) {
                if(introControls) introControls.textContent = 'Joystick - Mover | ‚¨ÜÔ∏è - Saltar | üî¶ - Linterna | E - Interactuar';
                if(controlsHUD) controlsHUD.textContent = 'Joystick - Mover | ‚¨ÜÔ∏è - Saltar | üèÉ - Correr';
                if(controlsHUD2) controlsHUD2.textContent = 'üî¶ - Linterna | Pantalla Derecha - C√°mara';
                if(controlsHUD3) controlsHUD3.textContent = 'E - Interactuar';
            } else if(hasGamepad) {
                if(introControls) introControls.textContent = 'Stick Izq - Mover | A - Saltar | X - Linterna | B - Interactuar';
                if(controlsHUD) controlsHUD.textContent = 'Stick Izq - Mover | A - Saltar | L/R - Correr';
                if(controlsHUD2) controlsHUD2.textContent = 'X - Linterna | Y - Mirar Atr√°s | Start - Pantalla Completa';
                if(controlsHUD3) controlsHUD3.textContent = 'B - Interactuar | Stick Der - C√°mara';
                
                // Ocultar bot√≥n de configuraci√≥n en consola
                const settingsBtn = document.getElementById('settingsBtn');
                if(settingsBtn) settingsBtn.style.display = 'none';
            }
        });

        function showTutorial() {
            if(tutorialShown) return;
            tutorialShown = true;
            
            const tutorialContent = document.getElementById('tutorialContent');
            const gamepads = navigator.getGamepads();
            const hasGamepad = gamepads && gamepads[0];
            
            if(isMobile) {
                tutorialContent.innerHTML = `
                    <p><strong>Joystick Izquierdo</strong> - Moverte</p>
                    <p><strong>‚¨ÜÔ∏è</strong> - Saltar obst√°culos</p>
                    <p><strong>üèÉ</strong> - Correr (consume stamina)</p>
                    <p><strong>üî¶</strong> - Encender/Apagar linterna</p>
                    <p><strong>Pantalla Derecha</strong> - Mover c√°mara</p>
                    <p><strong>E</strong> - Interactuar con objetos</p>
                `;
            } else if(hasGamepad) {
                tutorialContent.innerHTML = `
                    <p><strong>Stick Izquierdo</strong> - Moverte</p>
                    <p><strong>A</strong> - Saltar obst√°culos</p>
                    <p><strong>L1/R1/L2/R2</strong> - Correr (consume stamina)</p>
                    <p><strong>X</strong> - Encender/Apagar linterna</p>
                    <p><strong>Y</strong> - Mirar atr√°s</p>
                    <p><strong>B</strong> - Interactuar con objetos</p>
                    <p><strong>Stick Derecho</strong> - Mover c√°mara</p>
                    <p><strong>Start</strong> - Pantalla completa</p>
                    <p><strong>Select</strong> - Ver tutorial</p>
                `;
            } else {
                tutorialContent.innerHTML = `
                    <p><strong>WASD</strong> - Moverte</p>
                    <p><strong>ESPACIO</strong> - Saltar obst√°culos</p>
                    <p><strong>SHIFT</strong> - Correr (consume stamina)</p>
                    <p><strong>F</strong> - Encender/Apagar linterna</p>
                    <p><strong>C</strong> - Mirar atr√°s</p>
                    <p><strong>E</strong> - Interactuar con objetos</p>
                `;
            }
            
            document.getElementById('tutorial').style.display = 'block';
            document.exitPointerLock();
        }

        function closeTutorial() {
            document.getElementById('tutorial').style.display = 'none';
        }

        function showJumpCooldown() {
            const cooldownEl = document.getElementById('jumpCooldown');
            if(!cooldownEl) return;
            
            cooldownEl.style.display = 'flex';
            let remaining = jumpCooldown;
            const interval = setInterval(() => {
                remaining -= 100;
                cooldownEl.textContent = Math.ceil(remaining / 1000);
                if(remaining <= 0) {
                    clearInterval(interval);
                    cooldownEl.style.display = 'none';
                    cooldownEl.textContent = '‚è±Ô∏è';
                }
            }, 100);
        }

        function initAudio() {
            if(audioInitialized) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Ambient drone
            ambientSound = createDroneSound(80, 0.15);
            
            // Breathing
            breathingSound = createBreathingSound();
            
            // Footstep audio
            footstepAudio = new Audio('stuff/stepsound.mp3');
            footstepAudio.volume = 0.3;
            footstepAudio.addEventListener('canplaythrough', () => updateLoading('Audio: Pasos'), { once: true });
            
            // Flashlight audio
            flashlightAudio = new Audio('stuff/flashlight.mp3');
            flashlightAudio.volume = 0.4;
            flashlightAudio.addEventListener('canplaythrough', () => updateLoading('Audio: Linterna'), { once: true });
            
            // Solo cargar audios cr√≠ticos al inicio
            footstepAudio = new Audio('stuff/stepsound.mp3');
            footstepAudio.volume = 0.3;
            footstepAudio.addEventListener('canplaythrough', () => updateLoading('Audio: Pasos'), { once: true });
            
            flashlightAudio = new Audio('stuff/flashlight.mp3');
            flashlightAudio.volume = 0.4;
            flashlightAudio.addEventListener('canplaythrough', () => updateLoading('Audio: Linterna'), { once: true });
            
            // Cargar resto en background
            setTimeout(() => {
                jumpAudio = new Audio('stuff/salto.mp3');
                jumpAudio.volume = 0.4;
                runAudio = new Audio('stuff/correr.mp3');
                runAudio.volume = 0.4;
                runAudio.loop = true;
                exhaustedAudio = new Audio('stuff/exhausted.mp3');
                exhaustedAudio.volume = 0.5;
            }, 100);
            
            // Heartbeat audio (sintetizado)
            createHeartbeatSound();
            
            audioInitialized = true;
            initFootstepPool();
        }

        function createHeartbeatSound() {
            if(!audioContext) return;
            heartbeatAudio = {
                play: function(rate = 1.0) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.value = 80;
                    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioContext.currentTime + 0.1);
                },
                stop: function() {
                    if(heartbeatInterval) clearInterval(heartbeatInterval);
                }
            };
        }

        function startHeartbeat(distance) {
            if(heartbeatInterval) return;
            const baseRate = 800; // ms entre latidos
            const rate = Math.max(300, baseRate - (distance * 10)); // M√°s r√°pido cuando est√° cerca
            
            heartbeatInterval = setInterval(() => {
                if(heartbeatAudio && killerChasing) {
                    heartbeatAudio.play();
                    setTimeout(() => heartbeatAudio.play(), 150); // Doble latido
                }
            }, rate);
        }

        function stopHeartbeat() {
            if(heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        function updateHeartbeatRate(distance) {
            if(!killerChasing) return;
            stopHeartbeat();
            startHeartbeat(distance);
        }

        function createDroneSound(frequency, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            return { oscillator, gainNode };
        }

        function createBreathingSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(0.3, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            let breathingInterval;
            function startBreathing() {
                if(breathingInterval) clearInterval(breathingInterval);
                breathingInterval = setInterval(() => {
                    if(!audioContext) return;
                    const now = audioContext.currentTime;
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.08, now + 1.5);
                    gainNode.gain.linearRampToValueAtTime(0, now + 3);
                }, 3000);
            }
            startBreathing();
            
            return { oscillator, gainNode };
        }

        function playFlashlightSound() {
            if(!flashlightAudio) return;
            
            flashlightAudio.currentTime = 0;
            flashlightAudio.play().catch(() => {});
        }

        let footstepPool = [];
        let poolIndex = 0;
        
        function initFootstepPool() {
            for(let i = 0; i < 3; i++) {
                const audio = new Audio('stuff/stepsound.mp3');
                audio.volume = 0.25;
                footstepPool.push(audio);
            }
        }
        
        function playFootstepSound() {
            if(footstepPool.length === 0) return;
            const step = footstepPool[poolIndex];
            step.currentTime = 0;
            step.play().catch(() => {});
            poolIndex = (poolIndex + 1) % footstepPool.length;
        }

        function playJumpSound() {
            if(!jumpAudio) return;
            
            jumpAudio.currentTime = 0;
            jumpAudio.play().catch(() => {});
        }

        function startChase() {
            if(!chaseAudio || killerChasing) return;
            killerChasing = true;
            chaseAudio.currentTime = 0;
            chaseAudio.play().catch(() => {});
        }

        function playWhisper() {
            if(!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150 + Math.random() * 100, audioContext.currentTime);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 2);
        }

        function updateAmbientIntensity(distance) {
            if(!ambientSound) return;
            const intensity = Math.min(distance / 1000, 1);
            ambientSound.gainNode.gain.setValueAtTime(0.15 + intensity * 0.2, audioContext.currentTime);
            ambientSound.oscillator.frequency.setValueAtTime(80 - intensity * 20, audioContext.currentTime);
        }

        function updateFogDensity(distance) {
            // Zonas con niebla m√°s densa
            const denseFogZones = [
                { start: 150, end: 220, near: 0.5, far: 15 },
                { start: 350, end: 420, near: 0.3, far: 12 },
                { start: 600, end: 680, near: 0.4, far: 10 },
                { start: 800, end: 900, near: 0.2, far: 8 },
                { start: 1000, end: 1500, near: 0.1, far: 6 },
                { start: 1700, end: 1850, near: 0.3, far: 10 },
                { start: 2100, end: 2200, near: 0.2, far: 8 }
            ];
            
            let inDenseZone = false;
            for(let zone of denseFogZones) {
                if(distance >= zone.start && distance <= zone.end) {
                    targetFogNear = zone.near;
                    targetFogFar = zone.far;
                    inDenseZone = true;
                    break;
                }
            }
            
            if(!inDenseZone) {
                targetFogNear = scene.userData.baseFogNear;
                targetFogFar = scene.userData.baseFogFar;
            }
            
            // Transici√≥n suave (lerp)
            const lerpSpeed = 0.05;
            currentFogNear += (targetFogNear - currentFogNear) * lerpSpeed;
            currentFogFar += (targetFogFar - currentFogFar) * lerpSpeed;
            
            scene.fog.near = currentFogNear;
            scene.fog.far = currentFogFar;
        }

        function checkObjectFalls(distance) {
            for(let trigger of objectFallTriggers) {
                if(distance >= trigger && !triggeredFalls.has(trigger)) {
                    triggeredFalls.add(trigger);
                    spawnFallingObject(trigger);
                    break;
                }
            }
        }

        function checkGunshots(distance) {
            for(let trigger of gunshotTriggers) {
                if(distance >= trigger && !triggeredGunshots.has(trigger)) {
                    triggeredGunshots.add(trigger);
                    playGunshot();
                    showMonologue('*BANG*');
                    vibrateGamepad(200, 0.7, 0.7);
                    break;
                }
            }
        }
        
        function checkScream(distance) {
            const screamTrigger = 350 + Math.floor(Math.random() * 400);
            if(!screamTriggered && distance >= screamTrigger) {
                screamTriggered = true;
                playScream();
                showMonologue('¬øQu√© fue ese grito?');
                vibrateGamepad(400, 0.8, 0.8);
            }
        }
        
        function playScream() {
            if(!screamAudio) return;
            
            screamAudio.currentTime = 0;
            screamAudio.play().catch(() => {});
            
            setTimeout(() => {
                const echo1 = screamAudio.cloneNode();
                echo1.volume = 0.25;
                echo1.play().catch(() => {});
            }, 400);
            
            setTimeout(() => {
                const echo2 = screamAudio.cloneNode();
                echo2.volume = 0.12;
                echo2.play().catch(() => {});
            }, 800);
        }
        
        function checkMetalPipe(distance) {
            const pipeTrigger = 550 + Math.floor(Math.random() * 300);
            if(!metalPipeTriggered && distance >= pipeTrigger) {
                metalPipeTriggered = true;
                playMetalPipe();
                showMonologue('üíÄ METAL PIPE FALLING SOUND üíÄ');
                vibrateGamepad(600, 1.0, 1.0);
            }
        }
        
        function playMetalPipe() {
            if(!metalPipeAudio) return;
            
            // Sonido principal con AURA y fade in
            metalPipeAudio.volume = 0;
            metalPipeAudio.currentTime = 0;
            metalPipeAudio.play().catch(() => {});
            
            // Fade in r√°pido (0 a 0.8 en 100ms)
            let fadeInTime = 0;
            const fadeInInterval = setInterval(() => {
                fadeInTime += 10;
                metalPipeAudio.volume = Math.min(0.8, fadeInTime / 100 * 0.8);
                if(fadeInTime >= 100) clearInterval(fadeInInterval);
            }, 10);
            
            // Eco 1 - M√°s fuerte con fade
            setTimeout(() => {
                const echo1 = metalPipeAudio.cloneNode();
                echo1.volume = 0;
                echo1.play().catch(() => {});
                let t = 0;
                const i = setInterval(() => {
                    t += 10;
                    echo1.volume = Math.min(0.5, t / 80 * 0.5);
                    if(t >= 80) clearInterval(i);
                }, 10);
            }, 300);
            
            // Eco 2 - Medio con fade
            setTimeout(() => {
                const echo2 = metalPipeAudio.cloneNode();
                echo2.volume = 0;
                echo2.play().catch(() => {});
                let t = 0;
                const i = setInterval(() => {
                    t += 10;
                    echo2.volume = Math.min(0.3, t / 80 * 0.3);
                    if(t >= 80) clearInterval(i);
                }, 10);
            }, 600);
            
            // Eco 3 - Suave pero con AURA y fade
            setTimeout(() => {
                const echo3 = metalPipeAudio.cloneNode();
                echo3.volume = 0;
                echo3.play().catch(() => {});
                let t = 0;
                const i = setInterval(() => {
                    t += 10;
                    echo3.volume = Math.min(0.15, t / 80 * 0.15);
                    if(t >= 80) clearInterval(i);
                }, 10);
            }, 900);
        }
        
        function checkDripZones(distance) {
            if(killerChasing) {
                if(dripAudio && !dripAudio.paused) dripAudio.pause();
                return;
            }
            
            let closestDist = Infinity;
            for(let zone of dripZones) {
                const center = (zone.start + zone.end) / 2;
                const dist = Math.abs(distance - center);
                if(dist < closestDist) closestDist = dist;
            }
            
            const maxRange = 50;
            if(closestDist < maxRange) {
                if(dripAudio && dripAudio.paused) dripAudio.play().catch(() => {});
                const volume = Math.max(0, 0.3 * (1 - closestDist / maxRange));
                if(dripAudio) dripAudio.volume = volume;
            } else {
                if(dripAudio && !dripAudio.paused) dripAudio.pause();
            }
        }

        function playGunshot() {
            if(!gunshotAudio) return;
            
            // Reproducir sonido original
            const audio = gunshotAudio.cloneNode();
            audio.volume = 0.6;
            audio.play().catch(() => {});
            
            // Simular ecos con copias retrasadas
            setTimeout(() => {
                const echo1 = gunshotAudio.cloneNode();
                echo1.volume = 0.3;
                echo1.play().catch(() => {});
            }, 300);
            
            setTimeout(() => {
                const echo2 = gunshotAudio.cloneNode();
                echo2.volume = 0.15;
                echo2.play().catch(() => {});
            }, 600);
        }

        function checkCharacterIcons(posZ) {
            for(let icon of characterIcons) {
                if(!icon.shown && Math.abs(posZ - icon.z) < 3) {
                    icon.shown = true;
                    showMonologue(icon.text);
                    // Vibraci√≥n sutil al pasar cerca de un icono
                    vibrateGamepad(100, 0.2, 0.2);
                }
            }
        }

        function spawnFallingObject(zPos) {
            // Reproducir sonido
            if(objectFallAudio) {
                const audio = objectFallAudio.cloneNode();
                audio.volume = 0.5;
                audio.play().catch(() => {});
            }
            
            // Vibraci√≥n cuando cae un objeto
            vibrateGamepad(200, 0.6, 0.6);
            
            // Crear objeto cayendo
            const size = Math.random() * 0.5 + 0.3;
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(size, size, size),
                new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9, metalness: 0 })
            );
            
            // Posici√≥n aleatoria en el pasillo
            const side = Math.random() > 0.5 ? -3.5 : 3.5;
            mesh.position.set(side, 3.5, zPos + (Math.random() - 0.5) * 10);
            mesh.castShadow = true;
            scene.add(mesh);
            
            fallingObjects.push({
                mesh: mesh,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    0,
                    (Math.random() - 0.5) * 0.05
                ),
                angularVel: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                )
            });
        }

        function loadHallwayZone() {
            if(hallwayLoaded) return;
            hallwayLoaded = true;
            
            // Cargar audios del pasillo
            hallwayAudio = new Audio('stuff/pasillo1better.mp3');
            hallwayAudio.volume = 0;
            hallwayAudio.loop = false;
            
            cineAudio = new Audio('stuff/cine,,,.mp3');
            cineAudio.volume = 0.6;
            cineAudio.loop = false;
            
            doorBreakAudio = new Audio('stuff/puerarompiendose.mp3');
            doorBreakAudio.volume = 0.7;
            
            objectFallAudio = new Audio('stuff/obejtocayendose.mp3');
            objectFallAudio.volume = 0.5;
            
            gunshotAudio = new Audio('stuff/disparo.mp3');
            gunshotAudio.volume = 0.6;
            
            fanAudio = new Audio('stuff/ventilador.mp3');
            fanAudio.volume = 0.15;
            fanAudio.loop = true;
            
            screamAudio = new Audio('stuff/femalescream.mp3');
            screamAudio.volume = 0.5;
            
            iSeeYouAudio = new Audio('stuff/ISEEYOU.mp3');
            iSeeYouAudio.volume = 0.7;
            
            metalPipeAudio = new Audio('stuff/metal pipe.mp3');
            metalPipeAudio.volume = 0.8;
            
            dripAudio = new Audio('stuff/goteos.mp3');
            dripAudio.volume = 0.3;
            dripAudio.loop = true;
            
            // Zonas estrat√©gicas de goteras (cerca de tuber√≠as y grietas)
            dripZones = [
                { start: 100, end: 130 },
                { start: 280, end: 310 },
                { start: 450, end: 480 },
                { start: 620, end: 650 },
                { start: 780, end: 810 },
                { start: 920, end: 950 }
            ];
            
            // Reproducir audio de pasillo
            playHallwayAudio();
        }

        function loadGrassZone() {
            // Cargar audios de zona de pasto
            chaseAudio = new Audio('stuff/2019chase.mp3');
            chaseAudio.volume = 0.7;
            chaseAudio.loop = true;
            chaseAudio.addEventListener('ended', () => {
                if(killerChasing) chaseAudio.play();
            });
            
            rainAudio = new Audio('stuff/lluvia.mp3');
            rainAudio.volume = 0.4;
            rainAudio.loop = true;
            
            grassWalkAudio = new Audio('stuff/caminarpasto.mp3');
            grassWalkAudio.volume = 0.3;
            
            grassRunAudio = new Audio('stuff/correrpasto.mp3');
            grassRunAudio.volume = 0.4;
            grassRunAudio.loop = true;
        }

        function playHallwayAudio() {
            if(!hallwayAudio || hallwayAudioPlaying) return;
            hallwayAudioPlaying = true;
            
            // Fade in (2 segundos)
            hallwayAudio.volume = 0;
            hallwayAudio.play().catch(() => {});
            
            let fadeInInterval = setInterval(() => {
                if(hallwayAudio.volume < 0.5) {
                    hallwayAudio.volume = Math.min(hallwayAudio.volume + 0.05, 0.5);
                } else {
                    clearInterval(fadeInInterval);
                }
            }, 100);
            
            // Fade out (√∫ltimos 3 segundos)
            setTimeout(() => {
                let fadeOutInterval = setInterval(() => {
                    if(hallwayAudio.volume > 0) {
                        hallwayAudio.volume = Math.max(hallwayAudio.volume - 0.05, 0);
                    } else {
                        clearInterval(fadeOutInterval);
                        hallwayAudio.pause();
                        hallwayAudioPlaying = false;
                    }
                }, 100);
            }, 57000); // 60s - 3s fade out
        }

        // Ocultar intro despu√©s de que termine
        function hideIntro() {
            setTimeout(() => {
                const intro = document.getElementById('intro');
                intro.classList.add('hidden');
                
                // Efecto de despertar con parpadeo
                const blinkOverlay = document.createElement('div');
                blinkOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: #000; z-index: 2500; opacity: 1; transition: opacity 0.2s;
                `;
                document.body.appendChild(blinkOverlay);
                
                // Parpadeos r√°pidos
                setTimeout(() => blinkOverlay.style.opacity = '0', 100);
                setTimeout(() => blinkOverlay.style.opacity = '1', 300);
                setTimeout(() => blinkOverlay.style.opacity = '0', 500);
                setTimeout(() => blinkOverlay.style.opacity = '1', 800);
                setTimeout(() => {
                    blinkOverlay.style.opacity = '0';
                    setTimeout(() => blinkOverlay.remove(), 500);
                }, 1200);
                
                setTimeout(() => {
                    intro.style.display = 'none';
                    introShown = true;
                }, 2000);
            }, 32000);
        }

        // Inicializar audio con interacci√≥n del usuario
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('keydown', initAudio, { once: true });

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 50);
            scene.userData.baseFogNear = 1;
            scene.userData.baseFogFar = 30;

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, playerY, -3);

            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: 'low-power',
                precision: 'lowp',
                alpha: false,
                stencil: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            renderer.shadowMap.autoUpdate = false;
            document.body.appendChild(renderer.domElement);

            // Crear habitaci√≥n inicial
            createStartRoom();

            // Crear camino largo
            createLongPath();

            // Luz ambiental (cambia seg√∫n ubicaci√≥n)
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);

            // Linterna (apagada inicialmente)
            lamp = new THREE.SpotLight(0xffe680, 0, 35, Math.PI / 6, 0.3, 1.5);
            lamp.position.copy(camera.position);
            lamp.target.position.set(0, 0, -1);
            lamp.castShadow = true;
            lamp.shadow.mapSize.width = 256;
            lamp.shadow.mapSize.height = 256;
            lamp.shadow.camera.near = 0.5;
            lamp.shadow.camera.far = 10;
            lamp.shadow.bias = -0.001;
            scene.add(lamp);
            scene.add(lamp.target);

            // Controles
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            // Mobile
            if(isMobile) {
                document.getElementById('mobileControls').style.display = 'block';
                document.getElementById('sprintBtn').style.display = 'flex';
                setupMobileControls();
            }

            window.addEventListener('resize', onResize);
            window.addEventListener('gamepadconnected', () => console.log('Gamepad conectado'));

            animate();
        }

        function createLongPath() {
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1, metalness: 0, flatShading: true });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 1, metalness: 0, flatShading: true });
            const obstacleMat = new THREE.MeshStandardMaterial({ color: 0x4a0000, roughness: 0.9, metalness: 0, flatShading: true });
            const pipeMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.8, metalness: 0.3, flatShading: true });
            const bloodMat = new THREE.MeshBasicMaterial({ color: 0x330000, transparent: true, opacity: 0.6 });
            const crackMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
            
            const hallLength = 2500;
            
            // Suelo del pasillo (interior)
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 1000),
                floorMat
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = 500;
            floor.receiveShadow = false;
            scene.add(floor);
            platforms.push(floor);
            
            // Zona con pasto (1000-1800m)
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5016, roughness: 1, metalness: 0, flatShading: true });
            const grassFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 800),
                grassMat
            );
            grassFloor.rotation.x = -Math.PI / 2;
            grassFloor.position.z = 1400;
            grassFloor.receiveShadow = false;
            scene.add(grassFloor);
            platforms.push(grassFloor);
            
            // Suelo final (1800-2500m)
            const floor2 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 700),
                floorMat
            );
            floor2.rotation.x = -Math.PI / 2;
            floor2.position.z = 2150;
            floor2.receiveShadow = false;
            scene.add(floor2);
            platforms.push(floor2);
            
            // Techo del pasillo (antes de zona de pasto: 0-1000m)
            const ceilingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1, metalness: 0, flatShading: true });
            const ceiling1 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 1000),
                ceilingMat
            );
            ceiling1.rotation.x = Math.PI / 2;
            ceiling1.position.y = 4;
            ceiling1.position.z = 500;
            scene.add(ceiling1);
            
            // Techo despu√©s de zona de pasto (1800-2500m)
            const ceiling2 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 700),
                ceilingMat
            );
            ceiling2.rotation.x = Math.PI / 2;
            ceiling2.position.y = 4;
            ceiling2.position.z = 2150;
            scene.add(ceiling2);

            // Paredes antes de zona de pasto (0-1000m)
            const wallLeft1 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 1000),
                wallMat
            );
            wallLeft1.position.set(-5, 2, 500);
            wallLeft1.castShadow = true;
            scene.add(wallLeft1);

            const wallRight1 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 1000),
                wallMat
            );
            wallRight1.position.set(5, 2, 500);
            wallRight1.castShadow = true;
            scene.add(wallRight1);
            
            // Paredes despu√©s de zona de pasto (1800-2500m)
            const wallLeft2 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 700),
                wallMat
            );
            wallLeft2.position.set(-5, 2, 2150);
            wallLeft2.castShadow = true;
            scene.add(wallLeft2);

            const wallRight2 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 4, 700),
                wallMat
            );
            wallRight2.position.set(5, 2, 2150);
            wallRight2.castShadow = true;
            scene.add(wallRight2);

            // Paredes bajas que interrumpen el camino (antes de la persecuci√≥n)
            createParkourWalls(50, obstacleMat);
            createParkourWalls(200, obstacleMat);
            createParkourWalls(400, obstacleMat);
            createParkourWalls(600, obstacleMat);
            createParkourWalls(800, obstacleMat);
            
            // Obst√°culos de persecuci√≥n (1000-1500m) - Variados
            createChaseObstacles(obstacleMat);
            createVariedChaseObstacles(obstacleMat);
            
            // Paredes despu√©s de la persecuci√≥n
            createParkourWalls(1600, obstacleMat);
            createParkourWalls(1800, obstacleMat);
            createParkourWalls(2000, obstacleMat);
            createParkourWalls(2200, obstacleMat);
            createParkourWalls(2400, obstacleMat);

            // Obst√°culos adicionales
            const obstaclePositions = [
                { z: 120, type: 'wall' },
                { z: 320, type: 'pillars' },
                { z: 520, type: 'narrow' },
                { z: 720, type: 'boxes' },
                { z: 900, type: 'pillars' },
                { z: 1620, type: 'boxes' },
                { z: 1820, type: 'pillars' },
                { z: 2020, type: 'narrow' },
                { z: 2180, type: 'boxes' },
                { z: 2320, type: 'pillars' }
            ];

            obstaclePositions.forEach(obs => {
                if(obs.type === 'boxes') {
                    for(let i = 0; i < 6; i++) {
                        const box = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 1.5, 1.5),
                            obstacleMat
                        );
                        box.position.set((Math.random() - 0.5) * 6, 0.75, obs.z + (Math.random() - 0.5) * 15);
                        box.castShadow = true;
                        box.receiveShadow = true;
                        scene.add(box);
                        obstacles.push(box);
                    }
                } else if(obs.type === 'wall') {
                    const wall1 = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 3, 1),
                        obstacleMat
                    );
                    wall1.position.set(-2.5, 1.5, obs.z);
                    wall1.castShadow = true;
                    wall1.receiveShadow = true;
                    scene.add(wall1);
                    obstacles.push(wall1);

                    const wall2 = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 3, 1),
                        obstacleMat
                    );
                    wall2.position.set(2.5, 1.5, obs.z);
                    wall2.castShadow = true;
                    wall2.receiveShadow = true;
                    scene.add(wall2);
                    obstacles.push(wall2);
                } else if(obs.type === 'pillars') {
                    for(let i = -2; i <= 2; i++) {
                        if(i === 0) continue;
                        const pillar = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.5, 3.5, 8),
                            obstacleMat
                        );
                        pillar.position.set(i * 2, 1.75, obs.z);
                        pillar.castShadow = true;
                        pillar.receiveShadow = true;
                        scene.add(pillar);
                        obstacles.push(pillar);
                    }
                } else if(obs.type === 'narrow') {
                    const narrow1 = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 15),
                        obstacleMat
                    );
                    narrow1.position.set(-3, 1.5, obs.z);
                    narrow1.castShadow = true;
                    narrow1.receiveShadow = true;
                    scene.add(narrow1);
                    obstacles.push(narrow1);

                    const narrow2 = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 15),
                        obstacleMat
                    );
                    narrow2.position.set(3, 1.5, obs.z);
                    narrow2.castShadow = true;
                    narrow2.receiveShadow = true;
                    scene.add(narrow2);
                    obstacles.push(narrow2);
                }

                // Reducir luces (solo cada 3 obst√°culos)
                if(Math.random() > 0.7) {
                    const redLight = new THREE.PointLight(0xff0000, 0.5, 10);
                    redLight.position.set(0, 3, obs.z);
                    scene.add(redLight);
                }
            });

            // Puerta misteriosa en el pasillo
            createMysteryDoor(-4.5, 450);
            
            // Iconos de personajes en las paredes
            createCharacterIcons();
            
            // Ambiente del pasillo
            createHallwayAmbience(pipeMat, bloodMat, crackMat);

            // Cofre en 2450m
            createChest(0, 0.5, 2450);

            // Puerta de salida en 2500m
            createExitDoor(0, 2480);
            
            // Vegetaci√≥n en zona de c√©sped (1000-1800m)
            createGrassVegetation();
            
            // Ambiente del segundo pasillo (1800-2500m)
            createSecondHallwayAmbience(pipeMat, bloodMat, crackMat);
        }

        function createParkourWalls(startZ, material) {
            // Paredes bajas que cruzan el pasillo
            const walls = [
                { x: 0, z: startZ + 5, w: 8, h: 1.2, d: 0.5 },
                { x: -2, z: startZ + 15, w: 4, h: 1.2, d: 0.5 },
                { x: 2, z: startZ + 25, w: 4, h: 1.2, d: 0.5 },
                { x: 0, z: startZ + 35, w: 6, h: 1.2, d: 0.5 }
            ];

            walls.forEach(w => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(w.w, w.h, w.d),
                    material
                );
                wall.position.set(w.x, w.h / 2, w.z);
                wall.castShadow = false;
                wall.receiveShadow = false;
                scene.add(wall);
                obstacles.push(wall);
            });
        }

        function createVariedChaseObstacles(material) {
            // Cilindros
            for(let i = 0; i < 5; i++) {
                const cyl = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.4, 0.8, 8),
                    material
                );
                cyl.position.set((Math.random() - 0.5) * 4, 0.4, 1030 + i * 80);
                cyl.castShadow = false;
                scene.add(cyl);
                obstacles.push(cyl);
            }
            
            // Conos
            for(let i = 0; i < 4; i++) {
                const cone = new THREE.Mesh(
                    new THREE.ConeGeometry(0.5, 0.8, 8),
                    material
                );
                cone.position.set((Math.random() - 0.5) * 4, 0.4, 1100 + i * 90);
                cone.castShadow = false;
                scene.add(cone);
                obstacles.push(cone);
            }
            
            // Esferas
            for(let i = 0; i < 3; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    material
                );
                sphere.position.set((Math.random() - 0.5) * 4, 0.5, 1200 + i * 100);
                sphere.castShadow = false;
                scene.add(sphere);
                obstacles.push(sphere);
            }
        }

        function createChaseObstacles(material) {
            // Obst√°culos en el suelo durante la persecuci√≥n (1000-1500m)
            const chaseObstacles = [
                { x: 0, z: 1020, w: 6, h: 0.8, d: 2 },
                { x: -2, z: 1050, w: 3, h: 0.8, d: 2 },
                { x: 2, z: 1080, w: 3, h: 0.8, d: 2 },
                { x: 0, z: 1110, w: 7, h: 0.8, d: 2 },
                { x: -1, z: 1140, w: 4, h: 0.8, d: 2 },
                { x: 1, z: 1170, w: 4, h: 0.8, d: 2 },
                { x: 0, z: 1200, w: 5, h: 0.8, d: 2 },
                { x: -2, z: 1230, w: 3, h: 0.8, d: 2 },
                { x: 2, z: 1260, w: 3, h: 0.8, d: 2 },
                { x: 0, z: 1290, w: 6, h: 0.8, d: 2 },
                { x: -1, z: 1320, w: 4, h: 0.8, d: 2 },
                { x: 1, z: 1350, w: 4, h: 0.8, d: 2 },
                { x: 0, z: 1380, w: 7, h: 0.8, d: 2 },
                { x: -2, z: 1410, w: 3, h: 0.8, d: 2 },
                { x: 2, z: 1440, w: 3, h: 0.8, d: 2 }
            ];

            chaseObstacles.forEach(w => {
                const obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(w.w, w.h, w.d),
                    material
                );
                obstacle.position.set(w.x, w.h / 2, w.z);
                obstacle.castShadow = false;
                scene.add(obstacle);
                obstacles.push(obstacle);
            });
        }

        function createCharacterIcons() {
            const randomZ = Math.floor(Math.random() * 2300) + 100; // Entre 100-2400m
            const randomSide = Math.random() > 0.5 ? 'left' : 'right';
            
            const icons = [
                { path: '../assets/icons/GisselInactiveIcon.png', z: 150, side: 'left', text: 'Gissel estuvo aqu√≠...' },
                { path: '../assets/icons/IA777NormalIcon.png', z: 300, side: 'right', text: 'Sistema: Error 777' },
                { path: '../assets/icons/LunaNormalIcon.png', z: 500, side: 'left', text: '¬°Hola! Si ves esto... corre!' },
                { path: '../assets/icons/AngelNormalIcon.png', z: 650, side: 'right', text: 'No est√°s solo...' },
                { path: '../assets/icons/MollyNormalIcon.png', z: 750, side: 'left', text: 'Pelea o huye' },
                { path: '../assets/icons/IrisNormalIcon.png', z: 870, side: 'right', text: '√âl viene... lo siento...' },
                { path: '../assets/icons/ankush.png', z: randomZ, side: randomSide, text: 'Ankush estuvo aqu√≠... o no?' },
                { path: '../assets/icons/GisselInactiveIcon.png', z: 1650, side: 'left', text: 'Sobreviviste... sigue...' },
                { path: '../assets/icons/LunaNormalIcon.png', z: 1850, side: 'right', text: 'Ya casi... resiste...' },
                { path: '../assets/icons/IA777NormalIcon.png', z: 2000, side: 'left', text: 'Sistema: Peligro detectado' },
                { path: '../assets/icons/IrisNormalIcon.png', z: 2080, side: 'right', text: '√âl... √©l vuelve...' },
                { path: '../assets/icons/AngelNormalIcon.png', z: 2180, side: 'left', text: 'Mant√©n la esperanza...' },
                { path: '../assets/icons/MollyNormalIcon.png', z: 2280, side: 'right', text: 'No te rindas ahora' },
                { path: '../assets/icons/LunaNormalIcon.png', z: 2380, side: 'left', text: '¬°Vamos, casi est√°s ah√≠!' },
                { path: '../assets/icons/GisselInactiveIcon.png', z: 2430, side: 'right', text: 'La salida est√° cerca... corre' }
            ];
            
            icons.forEach(icon => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, 256, 256);
                    ctx.drawImage(img, 64, 64, 128, 128);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const plane = new THREE.Mesh(
                        new THREE.PlaneGeometry(1.5, 1.5),
                        material
                    );
                    
                    const x = icon.side === 'left' ? -4.4 : 4.4;
                    plane.position.set(x, 2, icon.z);
                    plane.rotation.y = icon.side === 'left' ? Math.PI / 2 : -Math.PI / 2;
                    
                    scene.add(plane);
                    characterIcons.push({ mesh: plane, z: icon.z, text: icon.text, shown: false });
                    
                    // Sin luz para optimizar
                };
                img.src = icon.path;
            });
        }

        function createMysteryDoor(x, z) {
            const doorFrame = new THREE.Group();
            
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(2, 3, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8, metalness: 0, flatShading: true })
            );
            doorFrame.add(frame);

            const doorMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 2.8, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9, metalness: 0, flatShading: true })
            );
            doorMesh.position.y = -0.1;
            doorMesh.userData.isDoor = true;
            doorFrame.add(doorMesh);

            doorFrame.position.set(x, 1.5, z);
            doorFrame.rotation.y = Math.PI / 2;
            scene.add(doorFrame);
            mysteryDoor = doorFrame;

            const doorLight = new THREE.PointLight(0xff4400, 0.5, 10);
            doorLight.position.set(x, 2.5, z);
            scene.add(doorLight);
        }

        function breakDoor() {
            if(doorBroken || !mysteryDoor) return;
            doorBroken = true;
            canInteractDoor = false;
            
            // Detener audio de cine si est√° sonando
            if(cineAudio) {
                cineAudio.pause();
                cineAudio.currentTime = 0;
            }
            
            // Reproducir sonido de puerta rompi√©ndose
            if(doorBreakAudio) {
                doorBreakAudio.currentTime = 0;
                doorBreakAudio.play().catch(() => {});
            }
            
            // Vibraci√≥n fuerte cuando la puerta se rompe
            vibrateGamepad(500, 1.0, 1.0);
            
            // Onda expansiva visual
            const shockwave = document.createElement('div');
            shockwave.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                width: 50px; height: 50px; border: 3px solid rgba(255,100,0,0.8);
                border-radius: 50%; z-index: 90; pointer-events: none;
            `;
            document.body.appendChild(shockwave);
            
            let waveSize = 50;
            const waveInterval = setInterval(() => {
                waveSize += 100;
                shockwave.style.width = waveSize + 'px';
                shockwave.style.height = waveSize + 'px';
                shockwave.style.opacity = 1 - (waveSize / 1000);
                if(waveSize >= 1000) {
                    clearInterval(waveInterval);
                    shockwave.remove();
                }
            }, 16);
            
            // Crear m√°s fragmentos
            const doorPos = mysteryDoor.position;
            for(let i = 0; i < 30; i++) {
                const fragment = new THREE.Mesh(
                    new THREE.BoxGeometry(Math.random() * 0.3 + 0.1, Math.random() * 0.3 + 0.1, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9, metalness: 0 })
                );
                fragment.position.copy(doorPos);
                fragment.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.4
                );
                fragment.angularVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                fragment.castShadow = true;
                scene.add(fragment);
                doorFragments.push(fragment);
            }
            
            // Remover puerta
            scene.remove(mysteryDoor);
            mysteryDoor = null;
            
            // Shake de c√°mara m√°s intenso
            const originalY = camera.position.y;
            const originalX = camera.position.x;
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                camera.position.y = originalY + Math.sin(shakeTime * 80) * 0.12;
                camera.position.x = originalX + Math.cos(shakeTime * 60) * 0.08;
                camera.rotation.z = Math.sin(shakeTime * 100) * 0.05;
                shakeTime += 0.016;
                if(shakeTime > 0.8) {
                    camera.position.y = originalY;
                    camera.position.x = originalX;
                    camera.rotation.z = 0;
                    clearInterval(shakeInterval);
                }
            }, 16);
            
            // Flash blanco
            renderer.domElement.style.filter = 'brightness(2.5)';
            setTimeout(() => renderer.domElement.style.filter = 'brightness(1)', 100);
            
            // Mon√≥logo de susto
            setTimeout(() => showMonologue('¬°¬øQU√â FUE ESO?!'), 500);
        }

        function createExitDoor(x, z) {
            const doorFrame = new THREE.Group();
            
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(4, 3.5, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7, metalness: 0, flatShading: true })
            );
            doorFrame.add(frame);

            const doorMesh = new THREE.Mesh(
                new THREE.BoxGeometry(3, 3, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8, metalness: 0, flatShading: true })
            );
            doorMesh.position.y = -0.25;
            doorFrame.add(doorMesh);

            doorFrame.position.set(x, 1.75, z);
            scene.add(doorFrame);
            exitDoor = doorFrame;

            const doorLight = new THREE.PointLight(0x00ff00, 1.5, 20);
            doorLight.position.set(x, 2.5, z);
            scene.add(doorLight);
        }

        function createChest(x, y, z) {
            const group = new THREE.Group();
            
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.8, 1),
                new THREE.MeshStandardMaterial({ color: 0x4a2511, roughness: 0.7, metalness: 0, flatShading: true })
            );
            base.castShadow = true;
            group.add(base);

            const lid = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.3, 1),
                new THREE.MeshStandardMaterial({ color: 0x5a3521, roughness: 0.7, metalness: 0, flatShading: true })
            );
            lid.position.y = 0.55;
            lid.castShadow = true;
            group.add(lid);

            const lock = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.3, 0.1),
                new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, metalness: 0.8 })
            );
            lock.position.set(0, 0.4, 0.51);
            group.add(lock);

            group.position.set(x, y, z);
            group.rotation.y = Math.PI; // Mirando hacia el jugador (hacia +Z)
            scene.add(group);
            chest = group;

            const chestLight = new THREE.PointLight(0xffd700, 1, 15);
            chestLight.position.set(x, y + 2, z);
            scene.add(chestLight);
        }

        function setupMobileControls() {
            const joystick = document.getElementById('joystick');
            const stick = document.getElementById('stick');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if(!joystickActive) return;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                joystickX = (touch.clientX - centerX) / 35;
                joystickY = (touch.clientY - centerY) / 35;
                joystickX = Math.max(-1, Math.min(1, joystickX));
                joystickY = Math.max(-1, Math.min(1, joystickY));
                stick.style.left = (35 + joystickX * 35) + 'px';
                stick.style.top = (35 + joystickY * 35) + 'px';
            });
            
            joystick.addEventListener('touchend', () => {
                joystickActive = false;
                joystickX = 0;
                joystickY = 0;
                stick.style.left = '35px';
                stick.style.top = '35px';
            });

            document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                const now = Date.now();
                if(onGround && !isJumping && now - lastJumpTime >= jumpCooldown) {
                    isJumping = true;
                    jumpVelocity = JUMP_FORCE;
                    onGround = false;
                    lastJumpTime = now;
                    playJumpSound();
                    showJumpCooldown();
                }
            });
            
            document.getElementById('sprintBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                isRunning = true;
            });
            
            document.getElementById('sprintBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                isRunning = false;
            });

            document.getElementById('interactBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(canInteract && chest) openLore();
                else if(canInteractPainting && !paintingInteracted) interactPainting();
            });
            
            // Control de c√°mara t√°ctil
            const cameraControl = document.getElementById('cameraControl');
            let touchStartX = 0, touchStartY = 0;
            
            cameraControl.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            cameraControl.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                mouseX -= deltaX * 0.005 * mouseSensitivity;
                mouseY -= deltaY * 0.005 * mouseSensitivity;
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            // Bot√≥n de linterna
            document.getElementById('flashlightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleFlashlight();
            });
            
            // Bot√≥n de correr
            document.getElementById('runBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                isRunning = true;
            });
            
            document.getElementById('runBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                isRunning = false;
            });
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyC':
                    lookingBack = true;
                    break;
                case 'Space':
                    const now = Date.now();
                    if(onGround && !isJumping && now - lastJumpTime >= jumpCooldown) {
                        isJumping = true;
                        jumpVelocity = JUMP_FORCE;
                        onGround = false;
                        lastJumpTime = now;
                        playJumpSound();
                        showJumpCooldown();
                    }
                    break;
                case 'KeyE': 
                    if(canInteract && !hasFlashlight) pickupFlashlight();
                    else if(canInteract && chest) openLore();
                    else if(canInteractDoor && !doorBroken) breakDoor();
                    else if(canInteractPainting && !paintingInteracted) interactPainting();
                    break;
                case 'KeyF': toggleFlashlight(); break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
                case 'KeyC':
                    lookingBack = false;
                    break;
            }
        }

        function onMouseMove(e) {
            if(document.pointerLockElement) {
                mouseX -= e.movementX * 0.002 * mouseSensitivity;
                mouseY -= e.movementY * 0.002 * mouseSensitivity;
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
            }
        }

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const chapterPanel = document.getElementById('chapterPanel');
            if(chapterPanel) chapterPanel.style.display = 'none';
            panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
        }

        function toggleChapters() {
            const panel = document.getElementById('chapterPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            if(settingsPanel) settingsPanel.style.display = 'none';
            panel.style.display = panel.style.display === 'none' || !panel.style.display ? 'block' : 'none';
            checkChapter2Unlock();
        }

        function checkChapter2Unlock() {
            const chapter2Item = document.getElementById('chapter2Item');
            if(localStorage.getItem('chapter2Unlocked') === 'true') {
                chapter2Item.classList.remove('locked');
                chapter2Item.querySelector('div:last-child').innerHTML = '<span style="color: #44ff44;">‚úîÔ∏è Desbloqueado</span>';
            }
        }

        function loadChapter(num) {
            if(num === 2 && localStorage.getItem('chapter2Unlocked') !== 'true') {
                showMonologue('üîí Cap√≠tulo 2 bloqueado - Completa el Cap√≠tulo 1 o usa el c√≥digo secreto');
                vibrateGamepad(200, 0.3, 0.3);
                return;
            }
            
            if(num === 1) {
                location.reload();
            } else if(num === 2) {
                toggleChapters();
                if(typeof unlockChapter2 === 'function') {
                    unlockChapter2();
                }
            }
        }

        async function validateSecretCode() {
            const input = document.getElementById('secretCodeInput');
            const message = document.getElementById('codeMessage');
            const code = input.value.trim();
            
            if(!code) {
                message.textContent = '';
                message.className = '';
                return;
            }
            
            if(typeof checkSecretCode === 'function' && await checkSecretCode(code)) {
                message.textContent = '‚úîÔ∏è C√≥digo correcto!';
                message.className = 'success';
                input.disabled = true;
                
                localStorage.setItem('chapter2Unlocked', 'true');
                
                setTimeout(() => {
                    toggleSettings();
                    checkChapter2Unlock();
                    if(typeof unlockChapter2 === 'function') {
                        unlockChapter2();
                    }
                }, 1000);
            } else {
                message.textContent = '‚ùå C√≥digo incorrecto';
                message.className = '';
                vibrateGamepad(200, 0.3, 0.3);
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    showMonologue('üì∫ Pantalla completa activada');
                }).catch(err => {
                    showMonologue('‚ö†Ô∏è No se pudo activar pantalla completa');
                });
            } else {
                document.exitFullscreen();
                showMonologue('üì∫ Pantalla completa desactivada');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const sensitivitySlider = document.getElementById('sensitivitySlider');
            const brightnessSlider = document.getElementById('brightnessSlider');
            const sensitivityValue = document.getElementById('sensitivityValue');
            const brightnessValue = document.getElementById('brightnessValue');
            const secretCodeInput = document.getElementById('secretCodeInput');

            sensitivitySlider.addEventListener('input', (e) => {
                mouseSensitivity = parseFloat(e.target.value);
                sensitivityValue.textContent = mouseSensitivity.toFixed(1) + 'x';
            });

            brightnessSlider.addEventListener('input', (e) => {
                screenBrightness = parseFloat(e.target.value);
                brightnessValue.textContent = Math.round(screenBrightness * 100) + '%';
                renderer.domElement.style.filter = `brightness(${screenBrightness})`;
            });

            if(secretCodeInput) {
                secretCodeInput.addEventListener('input', validateSecretCode);
                secretCodeInput.addEventListener('keypress', (e) => {
                    if(e.key === 'Enter') {
                        validateSecretCode();
                    }
                });
            }
            
            checkChapter2Unlock();
        });

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function vibrateGamepad(duration = 100, weakMagnitude = 0.5, strongMagnitude = 0.5) {
            const gamepads = navigator.getGamepads();
            if(!gamepads[0] || !gamepads[0].vibrationActuator) return;
            
            gamepads[0].vibrationActuator.playEffect('dual-rumble', {
                duration: duration,
                weakMagnitude: weakMagnitude,
                strongMagnitude: strongMagnitude
            });
        }

        function updateGamepad() {
            const gamepads = navigator.getGamepads();
            if(!gamepads[0]) return;
            
            const gp = gamepads[0];
            const deadzone = 0.2;
            
            // Stick izquierdo
            if(Math.abs(gp.axes[0]) > deadzone) joystickX = gp.axes[0];
            else joystickX = 0;
            if(Math.abs(gp.axes[1]) > deadzone) joystickY = gp.axes[1];
            else joystickY = 0;
            
            // Stick derecho para c√°mara
            if(Math.abs(gp.axes[2]) > deadzone) mouseX -= gp.axes[2] * 0.05;
            if(Math.abs(gp.axes[3]) > deadzone) mouseY -= gp.axes[3] * 0.05;
            mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
            
            // Botones
            // A - Saltar
            if(gp.buttons[0].pressed && onGround && !isJumping) {
                const now = Date.now();
                if(now - lastJumpTime >= jumpCooldown) {
                    isJumping = true;
                    jumpVelocity = JUMP_FORCE;
                    onGround = false;
                    lastJumpTime = now;
                    playJumpSound();
                    showJumpCooldown();
                }
            }
            // B - Interactuar
            if(gp.buttons[1].pressed) {
                if(canInteract && !hasFlashlight) pickupFlashlight();
                else if(canInteract && chest) openLore();
                else if(canInteractDoor && !doorBroken) breakDoor();
                else if(canInteractPainting && !paintingInteracted) interactPainting();
            }
            // X - Linterna
            if(gp.buttons[2].pressed) toggleFlashlight();
            // Y - Mirar atr√°s
            if(gp.buttons[3].pressed) lookingBack = true;
            else lookingBack = false;
            // L1/R1 o L2/R2 - Correr (solo uno a la vez)
            if(gp.buttons[4].pressed || gp.buttons[5].pressed || gp.buttons[6].value > 0.5 || gp.buttons[7].value > 0.5) {
                isRunning = true;
            } else {
                isRunning = false;
            }
            // Start - Pantalla completa (en consola)
            if(gp.buttons[9].pressed && !gp.buttons[9].wasPressed) {
                toggleFullscreen();
                gp.buttons[9].wasPressed = true;
            } else if(!gp.buttons[9].pressed) {
                gp.buttons[9].wasPressed = false;
            }
            // Select - Tutorial
            if(gp.buttons[8].pressed && !gp.buttons[8].wasPressed) {
                showTutorial();
                gp.buttons[8].wasPressed = true;
            } else if(!gp.buttons[8].pressed) {
                gp.buttons[8].wasPressed = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if(chapter2.active) {
                const delta = 0.016;
                chapter2.update(delta);
                renderer.render(scene, camera);
                return;
            }

            if(cinematicPlaying) {
                renderer.render(scene, camera);
                return;
            }

            updateGamepad();

            // Sistema de stamina
            if(isRunning && stamina > 0 && !staminaExhausted && (moveForward || moveBackward || moveLeft || moveRight)) {
                const staminaDrain = killerChasing ? 0.2 : 0.5;
                stamina -= staminaDrain;
                
                // Si se agota completamente
                if(stamina <= 0) {
                    stamina = 0;
                    staminaExhausted = true;
                    isRunning = false;
                    
                    // Reproducir sonido de agotamiento
                    if(exhaustedAudio) {
                        exhaustedAudio.currentTime = 0;
                        exhaustedAudio.play().catch(() => {});
                    }
                }
            } else if(stamina < maxStamina) {
                stamina += 0.2;
                
                // Solo puede volver a correr cuando se llena completamente
                if(stamina >= maxStamina) {
                    stamina = maxStamina;
                    staminaExhausted = false;
                }
            }
            
            document.getElementById('staminaFill').style.width = (stamina / maxStamina * 100) + '%';
            
            // Cambiar color seg√∫n estado
            if(staminaExhausted) {
                document.getElementById('staminaBar').style.borderColor = '#ff0000';
                document.getElementById('staminaFill').style.background = 'linear-gradient(90deg, #ff0000, #ff8888)';
            } else if(stamina < 30) {
                document.getElementById('staminaBar').style.borderColor = '#ffaa00';
                document.getElementById('staminaFill').style.background = 'linear-gradient(90deg, #ffaa00, #ffdd88)';
            } else {
                document.getElementById('staminaBar').style.borderColor = '#00ff00';
                document.getElementById('staminaFill').style.background = 'linear-gradient(90deg, #00ff00, #88ff88)';
            }

            // Movimiento
            velocity.x = 0;
            velocity.z = 0;

            let baseSpeed = 0.04;
            if(isRunning && stamina > 0 && !staminaExhausted) baseSpeed = 0.07;
            if(killerChasing) baseSpeed = isRunning && stamina > 0 && !staminaExhausted ? 0.08 : 0.05;
            
            const speed = baseSpeed;
            const isMoving = moveForward || moveBackward || moveLeft || moveRight || Math.abs(joystickX) > 0.1 || Math.abs(joystickY) > 0.1;
            
            if(moveForward || joystickY < -0.1) velocity.z -= speed;
            if(moveBackward || joystickY > 0.1) velocity.z += speed;
            if(moveLeft || joystickX < -0.1) velocity.x -= speed;
            if(moveRight || joystickX > 0.1) velocity.x += speed;

            // Determinar si est√° en zona de pasto
            const onGrass = camera.position.z >= 1000 && camera.position.z <= 1800;
            
            // Audio de correr
            if(isRunning && isMoving && stamina > 0 && !staminaExhausted) {
                if(!runAudioPlaying) {
                    runAudioPlaying = true;
                    if(onGrass && grassRunAudio) {
                        grassRunAudio.play().catch(() => {});
                    } else if(runAudio) {
                        runAudio.play().catch(() => {});
                    }
                }
            } else {
                if(runAudioPlaying) {
                    runAudioPlaying = false;
                    if(runAudio) runAudio.pause();
                    if(grassRunAudio) grassRunAudio.pause();
                }
            }
            
            // Footsteps solo cuando NO est√° corriendo
            if(isMoving && !isRunning) {
                footstepTimer += 16;
                if(footstepTimer >= footstepInterval) {
                    if(onGrass && grassWalkAudio) {
                        const audio = grassWalkAudio.cloneNode();
                        audio.volume = 0.3;
                        audio.play().catch(() => {});
                    } else {
                        playFootstepSound();
                    }
                    
                    const now = Date.now();
                    if(now - lastFootstepVibration > 500) {
                        vibrateGamepad(50, 0.1, 0.1);
                        lastFootstepVibration = now;
                    }
                    
                    footstepTimer = 0;
                }
            } else if(!isMoving) {
                footstepTimer = 0;
            }

            // Rotaci√≥n (mirar atr√°s)
            camera.rotation.order = 'YXZ';
            if(lookingBack) {
                camera.rotation.y = mouseX + Math.PI;
            } else {
                camera.rotation.y = mouseX;
            }
            camera.rotation.x = mouseY;

            // Direcci√≥n
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(camera.up, direction).normalize();

            camera.position.addScaledVector(direction, -velocity.z);
            camera.position.addScaledVector(right, -velocity.x);

            // Sistema de salto y gravedad
            if(isJumping || !onGround) {
                playerY += jumpVelocity;
                jumpVelocity -= GRAVITY;
                
                // Aterrizar
                if(playerY <= GROUND_Y) {
                    playerY = GROUND_Y;
                    isJumping = false;
                    onGround = true;
                    jumpVelocity = 0;
                }
            }
            
            // Aplicar posici√≥n Y ANTES de la animaci√≥n de correr
            camera.position.y = playerY;

            // Colisi√≥n con obst√°culos (solo muy cercanos, cada 3 frames)
            if(Date.now() % 3 === 0) {
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(camera.position.x - 0.3, playerY - 1.6, camera.position.z - 0.3),
                    new THREE.Vector3(camera.position.x + 0.3, playerY, camera.position.z + 0.3)
                );
                
                for(let obstacle of obstacles) {
                    // Solo verificar obst√°culos muy cercanos
                    const dist = Math.abs(obstacle.position.z - camera.position.z);
                    if(dist > 5) continue;
                    
                    const box = new THREE.Box3().setFromObject(obstacle);
                    if(playerBox.intersectsBox(box)) {
                        // Si el obst√°culo es bajo (< 1m) y est√°s corriendo, tropiezas
                        if(box.max.y < 1.0 && isRunning && !tripped) {
                            tripPlayer();
                        } else if(playerY > box.max.y) {
                            continue;
                        } else {
                            camera.position.addScaledVector(direction, velocity.z * 2);
                            camera.position.addScaledVector(right, velocity.x * 2);
                        }
                    }
                }
            }

            // L√≠mites
            if(inStartRoom) {
                camera.position.x = Math.max(-4.5, Math.min(4.5, camera.position.x));
                camera.position.z = Math.max(-9.5, Math.min(0.5, camera.position.z));
                
                    // Transici√≥n de habitaci√≥n a pasillo
                if(camera.position.z > 0 && hasFlashlight) {
                    inStartRoom = false;
                    scene.children.find(c => c instanceof THREE.AmbientLight).intensity = 0;
                    if(ceilingLight) ceilingLight.intensity = 0;
                    
                    // Mostrar ubicaci√≥n y cargar zona pasillo
                    if(!locationShown) {
                        showLocation('EL PASILLO', 'Dimensi√≥n Desconocida');
                        loadHallwayZone();
                        locationShown = true;
                    }
                }
            } else {
                camera.position.x = Math.max(-4.5, Math.min(4.5, camera.position.x));
                camera.position.z = Math.max(1, Math.min(2550, camera.position.z));
            }

            // Cargar zona de pasto (usar posici√≥n Z)
            if(!grassZoneLoaded && camera.position.z >= 900) {
                grassZoneLoaded = true;
                loadGrassZone();
            }
            
            // Spawn de 2019x en 1000m (usar posici√≥n Z)
            if(!killerSpawned && camera.position.z >= 1000) {
                killerSpawned = true;
                killerPosition = camera.position.z - 100; // Spawn 100m detr√°s
                spawn2019x();
                if(iSeeYouAudio) {
                    iSeeYouAudio.currentTime = 0;
                    iSeeYouAudio.play().catch(() => {});
                }
                showMonologue('¬°√âL EST√Å AQU√ç! ¬°CORRE!');
                startChase();
                vibrateGamepad(1000, 1.0, 1.0);
            }

            // 2019x persigue al jugador
            if(killerChasing && !isCaught) {
                // 2019x se mueve a velocidad constante (m√°s lento que el jugador corriendo)
                const killerSpeed = 0.065;
                killerPosition += killerSpeed;
                
                // Actualizar posici√≥n del modelo 3D
                if(killer2019x) {
                    killer2019x.position.z = killerPosition;
                    // Animaci√≥n de flotaci√≥n
                    killer2019x.position.y = 1.5 + Math.sin(Date.now() * 0.005) * 0.2;
                    killer2019x.rotation.y += 0.02;
                }
                
                // Calcular distancia real usando posici√≥n Z de la c√°mara
                const distanceToKiller = Math.abs(camera.position.z - killerPosition);
                
                // Actualizar indicador visual
                document.getElementById('killerIndicator').style.display = 'block';
                // Barra se llena cuando el killer est√° m√°s cerca (0m = 100%, 100m = 0%)
                const percentage = Math.max(0, Math.min(100, (1 - distanceToKiller / 100) * 100));
                document.getElementById('killerFill').style.width = percentage + '%';
                document.getElementById('killerText').textContent = `2019x: ${Math.floor(distanceToKiller)}m`;
                
                // Heartbeat basado en distancia
                if(distanceToKiller < 80) {
                    if(!heartbeatInterval) startHeartbeat(distanceToKiller);
                    else updateHeartbeatRate(distanceToKiller);
                }
                
                // Si 2019x alcanza al jugador
                if(distanceToKiller < killerCatchDistance) {
                    isCaught = true;
                    catchPlayer();
                }
            } else {
                document.getElementById('killerIndicator').style.display = 'none';
            }

            // Fin de la persecuci√≥n en 1500m
            if(killerChasing && camera.position.z >= 1500) {
                killerChasing = false;
                if(chaseAudio) chaseAudio.pause();
                stopHeartbeat();
                document.getElementById('killerIndicator').style.display = 'none';
                if(killer2019x) scene.remove(killer2019x);
                
                // Remover aura roja
                const redFog = document.querySelector('div[style*="radial-gradient"][style*="rgba(255,0,0"]');
                if(redFog) redFog.remove();
                
                showMonologue('Lo... lo logr√©... se detuvo...');
            }

            // Evento fantasma de 2019x en 2100m (aparece ADELANTE)
            if(!ghostEventTriggered && camera.position.z >= 2100 && camera.position.z < 2150) {
                ghostEventTriggered = true;
                spawn2019xGhost();
                showMonologue('¬°√âL EST√Å ADELANTE!');
                vibrateGamepad(500, 0.8, 0.8);
                
                // Desaparecer despu√©s de 4 segundos
                setTimeout(() => {
                    if(killer2019xGhost) {
                        // Fade out
                        let opacity = 0.6;
                        const fadeInterval = setInterval(() => {
                            opacity -= 0.05;
                            if(killer2019xGhost) {
                                killer2019xGhost.children.forEach(child => {
                                    if(child.material && child.material.transparent) {
                                        child.material.opacity = opacity;
                                    }
                                });
                            }
                            if(opacity <= 0) {
                                clearInterval(fadeInterval);
                                if(killer2019xGhost) {
                                    scene.remove(killer2019xGhost);
                                    killer2019xGhost = null;
                                }
                            }
                        }, 100);
                    }
                    showMonologue('Desapareci√≥... ¬øEra real?');
                }, 4000);
            }

            // Sistema de lluvia en zona de pasto
            if(camera.position.z >= 1000 && camera.position.z <= 1800) {
                if(!inRainZone) {
                    inRainZone = true;
                    startRain();
                }
                updateRain();
            } else {
                if(inRainZone) {
                    inRainZone = false;
                    stopRain();
                }
            }
            
            // Verificar si lleg√≥ a la puerta de salida
            if(!escaped && exitDoor && camera.position.z > 2480) {
                escaped = true;
                showEndSequence();
            }

            // Animaci√≥n de correr (solo si est√° en el suelo)
            if(onGround && !isJumping) {
                if(isRunning && isMoving && stamina > 0 && !staminaExhausted) {
                    runBobTime += 0.24;
                    camera.position.y = playerY + Math.sin(runBobTime) * 0.08;
                    camera.rotation.z = Math.sin(runBobTime * 0.5) * 0.02;
                } else if(isMoving) {
                    runBobTime += 0.13;
                    camera.position.y = playerY + Math.sin(runBobTime) * 0.03;
                } else {
                    camera.rotation.z = 0;
                    runBobTime = 0;
                }
            }
            
            // Actualizar linterna (optimizado)
            if(hasFlashlight && flashlightOn) {
                const lookDirection = new THREE.Vector3();
                camera.getWorldDirection(lookDirection);
                
                const rightVec = new THREE.Vector3();
                rightVec.crossVectors(new THREE.Vector3(0, 1, 0), lookDirection).normalize();
                
                lamp.position.copy(camera.position);
                lamp.position.add(rightVec.multiplyScalar(0.25));
                lamp.position.y -= 0.3;
                lamp.position.add(lookDirection.multiplyScalar(0.2));
                
                lamp.target.position.copy(lamp.position);
                lamp.target.position.add(lookDirection.multiplyScalar(10));
                
                lamp.intensity = 6.5;
                
                // Actualizar sombras solo cada 5 frames
                if(Date.now() % 5 === 0) {
                    renderer.shadowMap.needsUpdate = true;
                }
            } else {
                lamp.intensity = 0;
            }

            // Mon√≥logo (optimizado)
            if(!inStartRoom) {
                // Usar directamente la posici√≥n Z como distancia (sube y baja)
                const distance = Math.floor(Math.max(0, camera.position.z));
                
                // Actualizar HUD cada 5 frames
                if(Date.now() % 5 === 0) {
                    document.getElementById('distance').textContent = `Distancia: ${distance}m`;
                }
                
                // Usar posici√≥n Z para eventos (m√°s preciso)
                const posZ = Math.floor(camera.position.z);
                
                if(currentMonologue < monologues.length && posZ >= monologues[currentMonologue].dist) {
                    showMonologue(monologues[currentMonologue].text);
                    currentMonologue++;
                }
                
                // Actualizar ambiente cada 3 frames
                if(Date.now() % 3 === 0) {
                    updateAmbientIntensity(posZ);
                    updateFogDensity(posZ);
                }
                
                checkObjectFalls(posZ);
                checkGunshots(posZ);
                checkScream(posZ);
                checkMetalPipe(posZ);
                
                // Iconos cada 10 frames
                if(Date.now() % 10 === 0) checkCharacterIcons(posZ);
                
                // Susurros muy ocasionales
                if(Math.random() > 0.9998) {
                    playWhisper();
                }
                
                // Sistema de goteras por zonas
                checkDripZones(posZ);
            }
            
            // Actualizar objetos cayendo (solo si hay objetos, cada 2 frames)
            if(fallingObjects.length > 0 && Date.now() % 2 === 0) {
                for(let i = fallingObjects.length - 1; i >= 0; i--) {
                    const obj = fallingObjects[i];
                    obj.velocity.y -= 0.015;
                    obj.mesh.position.add(obj.velocity);
                    obj.mesh.rotation.x += obj.angularVel.x;
                    obj.mesh.rotation.y += obj.angularVel.y;
                    obj.mesh.rotation.z += obj.angularVel.z;
                    
                    if(obj.mesh.position.y < 0) {
                        scene.remove(obj.mesh);
                        fallingObjects.splice(i, 1);
                    }
                }
            }

            // Animar cables colgantes
            if(hangingCables.length > 0) {
                const time = Date.now() * 0.001;
                hangingCables.forEach(cable => {
                    cable.rotation.z = Math.sin(time + cable.userData.swingOffset) * 0.15;
                });
            }
            
            // Animar ventiladores y audio por proximidad
            if(ceilingFans.length > 0 && !killerChasing) {
                let nearFan = false;
                ceilingFans.forEach(fan => {
                    fan.rotation.y += fan.userData.speed;
                    const dist = Math.abs(camera.position.z - fan.position.z);
                    if(dist < 20) nearFan = true;
                });
                
                if(nearFan && !fanAudioPlaying && fanAudio) {
                    fanAudio.play().catch(() => {});
                    fanAudioPlaying = true;
                } else if(!nearFan && fanAudioPlaying && fanAudio) {
                    fanAudio.pause();
                    fanAudioPlaying = false;
                }
            } else if(fanAudioPlaying && fanAudio) {
                fanAudio.pause();
                fanAudioPlaying = false;
            }
            
            // Actualizar fragmentos de puerta (solo si hay fragmentos)
            if(doorFragments.length > 0) {
                for(let i = doorFragments.length - 1; i >= 0; i--) {
                    const frag = doorFragments[i];
                    frag.velocity.y -= 0.01;
                    frag.position.add(frag.velocity);
                    frag.rotation.x += frag.angularVelocity.x;
                    frag.rotation.y += frag.angularVelocity.y;
                    frag.rotation.z += frag.angularVelocity.z;
                    
                    if(frag.position.y < 0) {
                        scene.remove(frag);
                        doorFragments.splice(i, 1);
                    }
                }
            }

            // Audio de cine cuando se acerca a la puerta
            if(!doorBroken && mysteryDoor) {
                const distToDoor = camera.position.distanceTo(mysteryDoor.position);
                if(!cineAudioPlaying && distToDoor < 15) {
                    cineAudioPlaying = true;
                    if(cineAudio) {
                        cineAudio.currentTime = 0;
                        cineAudio.play().catch(() => {});
                    }
                }
            } else if(doorBroken && cineAudioPlaying) {
                // Detener audio si la puerta fue destruida
                if(cineAudio) {
                    cineAudio.pause();
                    cineAudio.currentTime = 0;
                }
                cineAudioPlaying = false;
            }

            // Interacci√≥n
            if(!escaped) {
                // Resetear estados
                canInteract = false;
                canInteractDoor = false;
                canInteractPainting = false;
                let interactText = '';
                
                // Verificar linterna
                if(!hasFlashlight && flashlight) {
                    const dist = camera.position.distanceTo(flashlight.position);
                    if(dist < 2) {
                        canInteract = true;
                        interactText = 'Presiona E para tomar linterna';
                    }
                }
                
                // Verificar cuadro
                if(inStartRoom && gisselPainting && !paintingInteracted) {
                    const dist = camera.position.distanceTo(gisselPainting.position);
                    if(dist < 3) {
                        canInteractPainting = true;
                        interactText = 'Presiona E para observar el cuadro';
                    }
                }
                
                // Verificar puerta misteriosa
                if(mysteryDoor && !doorBroken) {
                    const dist = camera.position.distanceTo(mysteryDoor.position);
                    if(dist < 3) {
                        canInteractDoor = true;
                        interactText = 'Presiona E para abrir puerta';
                    }
                }
                
                // Verificar cofre
                if(chest) {
                    const dist = camera.position.distanceTo(chest.position);
                    if(dist < 5) {
                        canInteract = true;
                        interactText = 'Presiona E para abrir cofre';
                    }
                }
                
                const showInteract = canInteract || canInteractDoor || canInteractPainting;
                document.getElementById('interact').style.display = showInteract ? 'block' : 'none';
                if(showInteract) document.getElementById('interact').textContent = interactText;
                
                if(isMobile) {
                    document.getElementById('interactBtn').style.display = showInteract ? 'flex' : 'none';
                }
            }

            // Efectos visuales
            updateVisualEffects();

            renderer.render(scene, camera);
        }

        function spawn2019xGhost() {
            const group = new THREE.Group();
            
            // Cuerpo semi-transparente m√°s grande
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.4, 2.5, 6),
                new THREE.MeshStandardMaterial({ color: 0x1a0000, roughness: 0.8, metalness: 0.2, transparent: true, opacity: 0.6, emissive: 0x330000, emissiveIntensity: 0.5 })
            );
            group.add(body);
            
            // Cabeza m√°s grande
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 6, 6),
                new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.3, transparent: true, opacity: 0.6, emissive: 0xff0000, emissiveIntensity: 0.8 })
            );
            head.position.y = 1.5;
            group.add(head);
            
            // Ojos brillantes
            const eye1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 4, 4),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1.0 })
            );
            eye1.position.set(-0.25, 1.6, 0.5);
            group.add(eye1);
            
            const eye2 = eye1.clone();
            eye2.position.set(0.25, 1.6, 0.5);
            group.add(eye2);
            
            // Luz roja intensa
            const light = new THREE.PointLight(0xff0000, 2.5, 30);
            light.position.y = 1.5;
            group.add(light);
            
            // Posici√≥n ADELANTE del jugador (30-40m)
            const spawnDistance = 35;
            group.position.set(0, 0, camera.position.z + spawnDistance);
            scene.add(group);
            killer2019xGhost = group;
        }

        function spawn2019x() {
            // Fade in gradual con niebla roja
            const redFog = document.createElement('div');
            redFog.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.4) 100%);
                z-index: 80; opacity: 0; transition: opacity 1s; pointer-events: none;
            `;
            document.body.appendChild(redFog);
            setTimeout(() => redFog.style.opacity = '1', 50);
            
            const group = new THREE.Group();
            group.scale.set(0, 0, 0); // Empieza invisible
            
            // Cuerpo oscuro
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.3, 2, 6),
                new THREE.MeshStandardMaterial({ color: 0x1a0000, roughness: 0.8, metalness: 0.2, emissive: 0x330000, emissiveIntensity: 0.3 })
            );
            group.add(body);
            
            // Cabeza/m√°scara
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 6, 6),
                new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.3, emissive: 0xff0000, emissiveIntensity: 0.6 })
            );
            head.position.y = 1.3;
            group.add(head);
            
            // Ojos rojos
            const eye1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 4, 4),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            eye1.position.set(-0.2, 1.4, 0.4);
            group.add(eye1);
            
            const eye2 = eye1.clone();
            eye2.position.set(0.2, 1.4, 0.4);
            group.add(eye2);
            
            // Luz roja
            const light = new THREE.PointLight(0xff0000, 2, 15);
            light.position.y = 1.5;
            group.add(light);
            
            group.position.set(0, 0, killerPosition);
            scene.add(group);
            killer2019x = group;
            
            // Animaci√≥n de aparici√≥n (scale de 0 a 1)
            let spawnTime = 0;
            const spawnInterval = setInterval(() => {
                spawnTime += 16;
                const progress = Math.min(spawnTime / 1000, 1);
                group.scale.set(progress, progress, progress);
                
                // Distorsi√≥n visual al aparecer
                if(progress < 1) {
                    applyDistortion(0.5 * (1 - progress));
                }
                
                if(spawnTime >= 1000) {
                    clearInterval(spawnInterval);
                    // Mantener niebla roja
                }
            }, 16);
        }

        function updateVisualEffects() {
            const vignetteEl = document.getElementById('vignette');
            
            // Vi√±eta oscura cuando stamina baja
            if(vignetteEl) {
                if(stamina < 30) {
                    const intensity = 1 - (stamina / 30);
                    vignetteEl.style.opacity = intensity * 0.8;
                } else {
                    vignetteEl.style.opacity = '0';
                }
            }
            
            // Distorsi√≥n cuando 2019x est√° cerca
            if(killerChasing && !isCaught) {
                // Usar Math.abs para calcular distancia correctamente
                const distanceToKiller = Math.abs(camera.position.z - killerPosition);
                if(distanceToKiller < 50) {
                    const intensity = 1 - (distanceToKiller / 50);
                    applyDistortion(intensity);
                } else {
                    const distEl = document.getElementById('distortion');
                    if(distEl) distEl.style.opacity = '0';
                }
            } else {
                const distEl = document.getElementById('distortion');
                if(distEl) distEl.style.opacity = '0';
            }
        }

        function applyDistortion(intensity) {
            if(!distortionCanvas) {
                distortionCanvas = document.getElementById('distortion');
                if(!distortionCanvas) return;
                distortionCanvas.width = window.innerWidth;
                distortionCanvas.height = window.innerHeight;
                distortionCtx = distortionCanvas.getContext('2d');
            }
            
            distortionCanvas.style.opacity = Math.min(intensity * 0.8, 0.8);
            distortionCtx.clearRect(0, 0, distortionCanvas.width, distortionCanvas.height);
            
            // Fondo rojo semi-transparente
            distortionCtx.fillStyle = `rgba(255, 0, 0, ${intensity * 0.1})`;
            distortionCtx.fillRect(0, 0, distortionCanvas.width, distortionCanvas.height);
            
            // L√≠neas de distorsi√≥n horizontales
            distortionCtx.strokeStyle = `rgba(255, 0, 0, ${intensity * 0.8})`;
            distortionCtx.lineWidth = 4;
            
            for(let i = 0; i < 20; i++) {
                const y = (i / 20) * distortionCanvas.height;
                const offset = Math.sin(Date.now() * 0.005 + i) * 50 * intensity;
                distortionCtx.beginPath();
                distortionCtx.moveTo(0, y);
                distortionCtx.lineTo(distortionCanvas.width, y + offset);
                distortionCtx.stroke();
            }
            
            // Bloques de glitch
            for(let i = 0; i < 5; i++) {
                const x = Math.random() * distortionCanvas.width;
                const y = Math.random() * distortionCanvas.height;
                const w = Math.random() * 200 + 50;
                const h = Math.random() * 50 + 10;
                distortionCtx.fillStyle = `rgba(255, 0, 0, ${intensity * 0.5})`;
                distortionCtx.fillRect(x, y, w, h);
            }
        }

        function showMonologue(text) {
            const monologue = document.createElement('div');
            monologue.className = 'monologue';
            monologue.textContent = text;
            monologue.style.left = (20 + Math.random() * 60) + '%';
            monologue.style.top = (20 + Math.random() * 60) + '%';
            document.body.appendChild(monologue);
            
            setTimeout(() => monologue.style.opacity = '1', 100);
            setTimeout(() => {
                monologue.style.opacity = '0';
                setTimeout(() => monologue.remove(), 1000);
            }, 5000);
        }

        function createStartRoom() {
            const roomMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.9, metalness: 0, flatShading: true });
            
            // Suelo
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 10),
                new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9, metalness: 0, flatShading: true })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = -5;
            floor.receiveShadow = true;
            scene.add(floor);

            // Paredes
            const walls = [
                { pos: [-5, 2, -5], size: [0.2, 4, 10] },
                { pos: [5, 2, -5], size: [0.2, 4, 10] },
                { pos: [0, 2, -10], size: [10, 4, 0.2] }
            ];
            walls.forEach(w => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(...w.size),
                    new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.9, metalness: 0, flatShading: true })
                );
                wall.position.set(...w.pos);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                obstacles.push(wall);
            });

            // Mesa
            table = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 1),
                new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7, metalness: 0, flatShading: true })
            );
            table.position.set(0, 0.4, -6);
            table.castShadow = true;
            table.receiveShadow = true;
            scene.add(table);
            obstacles.push(table);

            // Linterna en la mesa
            const flashlightGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 0.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.9 })
            );
            flashlightGroup.add(body);
            
            const lens = new THREE.Mesh(
                new THREE.CylinderGeometry(0.09, 0.09, 0.05, 8),
                new THREE.MeshStandardMaterial({ color: 0xffe680, roughness: 0.2, metalness: 0.8, emissive: 0xffe680, emissiveIntensity: 0.8 })
            );
            lens.position.y = 0.275;
            flashlightGroup.add(lens);
            
            const button = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.03, 0.06),
                new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.7 })
            );
            button.position.set(0, -0.1, 0.1);
            flashlightGroup.add(button);
            
            flashlightGroup.rotation.z = Math.PI / 2;
            flashlightGroup.position.set(0, 0.85, -6);
            flashlightGroup.traverse(child => {
                if(child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            scene.add(flashlightGroup);
            flashlight = flashlightGroup;
            
            // Luz de la linterna en la mesa
            const flashlightGlow = new THREE.PointLight(0xffe680, 0.8, 3);
            flashlightGlow.position.set(0, 0.85, -6);
            scene.add(flashlightGlow);

            // Luz de techo
            ceilingLight = new THREE.PointLight(0xffffff, 1.5, 15);
            ceilingLight.position.set(0, 3.5, -5);
            ceilingLight.castShadow = false;
            scene.add(ceilingLight);
            
            // Cuadro de Gissel en la pared (ULTRA OPTIMIZADO)
            const paintingTexture = new THREE.TextureLoader().load('stuff/Gisselcyber.jpg', (texture) => {
                // Optimizaciones agresivas
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false;
                texture.anisotropy = 1;
                updateLoading('Textura: Cuadro');
            });
            const paintingMaterial = new THREE.MeshStandardMaterial({ 
                map: paintingTexture,
                roughness: 0.8,
                metalness: 0,
                side: THREE.FrontSide
            });
            gisselPainting = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                paintingMaterial
            );
            gisselPainting.position.set(0, 2, -9.8);
            gisselPainting.castShadow = false;
            gisselPainting.receiveShadow = false;
            gisselPainting.frustumCulled = true; // Ocultar cuando no se ve
            scene.add(gisselPainting);
        }

        function interactPainting() {
            paintingInteracted = true;
            canInteractPainting = false;
            
            // Mostrar mensaje de Gissel
            showMonologue('Ya vete alv gissel');
            
            // Vibraci√≥n sutil
            vibrateGamepad(100, 0.2, 0.2);
        }
        
        function createGrassVegetation() {
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x1a3a0a, roughness: 1, metalness: 0 });
            const bushMat = new THREE.MeshStandardMaterial({ color: 0x2a4a1a, roughness: 0.9, metalness: 0 });
            
            // Pasto alto (cada 30m)
            for(let z = 1000; z < 1800; z += 30) {
                for(let i = 0; i < 8; i++) {
                    const grass = new THREE.Mesh(
                        new THREE.ConeGeometry(0.1, 0.4, 4),
                        grassMat
                    );
                    grass.position.set(
                        (Math.random() - 0.5) * 8,
                        0.2,
                        z + (Math.random() - 0.5) * 25
                    );
                    grass.rotation.z = (Math.random() - 0.5) * 0.3;
                    scene.add(grass);
                }
            }
            
            // Arbustos (cada 50m)
            for(let z = 1020; z < 1800; z += 50) {
                for(let i = 0; i < 3; i++) {
                    const bush = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 6, 6),
                        bushMat
                    );
                    bush.position.set(
                        (Math.random() - 0.5) * 7,
                        0.3,
                        z + (Math.random() - 0.5) * 40
                    );
                    bush.scale.set(1, 0.7, 1);
                    scene.add(bush);
                }
            }
            
            // √Årboles peque√±os (cada 80m)
            for(let z = 1050; z < 1800; z += 80) {
                const side = Math.random() > 0.5 ? -4 : 4;
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.2, 1.5, 6),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9, metalness: 0 })
                );
                trunk.position.set(side, 0.75, z);
                scene.add(trunk);
                
                const leaves = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 6, 6),
                    bushMat
                );
                leaves.position.set(side, 1.8, z);
                leaves.scale.set(1, 1.2, 1);
                scene.add(leaves);
            }
        }
        
        function createSecondHallwayAmbience(pipeMat, bloodMat, crackMat) {
            // Tuber√≠as (cada 100m)
            for(let z = 1850; z < 2500; z += 100) {
                const pipeL = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 50, 6),
                    pipeMat
                );
                pipeL.rotation.z = Math.PI / 2;
                pipeL.position.set(-4.8, 2.5, z);
                scene.add(pipeL);
                
                const pipeR = pipeL.clone();
                pipeR.position.set(4.8, 2.5, z);
                scene.add(pipeR);
            }
            
            // Cables colgantes (cada 80m)
            for(let z = 1900; z < 2500; z += 80) {
                const cable = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 1.5, 4),
                    new THREE.MeshBasicMaterial({ color: 0x222222 })
                );
                cable.position.set((Math.random() - 0.5) * 6, 3.5, z);
                cable.userData.swingOffset = Math.random() * Math.PI * 2;
                scene.add(cable);
                hangingCables.push(cable);
            }
            
            // Manchas de sangre (cada 150m)
            for(let z = 1880; z < 2500; z += 150) {
                const side = Math.random() > 0.5 ? -4.9 : 4.9;
                const bloodStain = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 1.2),
                    bloodMat
                );
                bloodStain.position.set(side, 1.5 + Math.random(), z);
                bloodStain.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;
                scene.add(bloodStain);
            }
            
            // Grietas con luz roja (cada 200m)
            for(let z = 1920; z < 2500; z += 200) {
                const side = Math.random() > 0.5 ? -4.9 : 4.9;
                const crack = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 2),
                    crackMat
                );
                crack.position.set(side, 2, z);
                crack.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;
                scene.add(crack);
                
                const crackLight = new THREE.PointLight(0xff0000, 0.3, 5);
                crackLight.position.set(side * 0.9, 2, z);
                scene.add(crackLight);
            }
            
            // Ventiladores (cada 150m)
            for(let z = 1900; z < 2500; z += 150) {
                const fanGroup = new THREE.Group();
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.9, metalness: 0.2 })
                );
                fanGroup.add(base);
                
                for(let i = 0; i < 3; i++) {
                    const blade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.05, 0.15),
                        new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8, metalness: 0.1 })
                    );
                    blade.rotation.y = (i * Math.PI * 2) / 3;
                    fanGroup.add(blade);
                }
                
                fanGroup.position.set((Math.random() - 0.5) * 4, 3.8, z);
                fanGroup.userData.speed = 0.01 + Math.random() * 0.02;
                scene.add(fanGroup);
                ceilingFans.push(fanGroup);
            }
        }
        
        function createHallwayAmbience(pipeMat, bloodMat, crackMat) {
            // Tuber√≠as en las paredes (cada 100m)
            for(let z = 50; z < 1000; z += 100) {
                // Tuber√≠a izquierda
                const pipeL = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 50, 6),
                    pipeMat
                );
                pipeL.rotation.z = Math.PI / 2;
                pipeL.position.set(-4.8, 2.5, z);
                scene.add(pipeL);
                
                // Tuber√≠a derecha
                const pipeR = pipeL.clone();
                pipeR.position.set(4.8, 2.5, z);
                scene.add(pipeR);
            }
            
            // Cables colgantes (cada 80m)
            for(let z = 100; z < 1000; z += 80) {
                const cable = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 1.5, 4),
                    new THREE.MeshBasicMaterial({ color: 0x222222 })
                );
                cable.position.set((Math.random() - 0.5) * 6, 3.5, z);
                cable.userData.swingOffset = Math.random() * Math.PI * 2;
                scene.add(cable);
                hangingCables.push(cable);
            }
            
            // Manchas de sangre en paredes (cada 150m)
            for(let z = 80; z < 1000; z += 150) {
                const side = Math.random() > 0.5 ? -4.9 : 4.9;
                const bloodStain = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 1.2),
                    bloodMat
                );
                bloodStain.position.set(side, 1.5 + Math.random(), z);
                bloodStain.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;
                scene.add(bloodStain);
            }
            
            // Grietas con luz roja (cada 200m)
            for(let z = 120; z < 1000; z += 200) {
                const side = Math.random() > 0.5 ? -4.9 : 4.9;
                const crack = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 2),
                    crackMat
                );
                crack.position.set(side, 2, z);
                crack.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;
                scene.add(crack);
                
                // Luz roja de la grieta
                const crackLight = new THREE.PointLight(0xff0000, 0.3, 5);
                crackLight.position.set(side * 0.9, 2, z);
                scene.add(crackLight);
            }
            
            // Puertas cerradas a los lados (cada 180m)
            for(let z = 140; z < 1000; z += 180) {
                const side = Math.random() > 0.5 ? -4.8 : 4.8;
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 2.5, 1.5),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9, metalness: 0 })
                );
                door.position.set(side, 1.25, z);
                scene.add(door);
            }
            
            // Carteles de advertencia (cada 250m)
            const warningTexts = ['PELIGRO', 'NO PASAR', 'ZONA RESTRINGIDA', 'SALIDA ‚Üí'];
            for(let z = 200; z < 1000; z += 250) {
                const side = Math.random() > 0.5 ? -4.9 : 4.9;
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 256, 128);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.strokeRect(10, 10, 236, 108);
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(warningTexts[Math.floor(Math.random() * warningTexts.length)], 128, 70);
                const texture = new THREE.CanvasTexture(canvas);
                const sign = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.5, 0.75),
                    new THREE.MeshBasicMaterial({ map: texture })
                );
                sign.position.set(side, 2.5, z);
                sign.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;
                scene.add(sign);
            }
            
            // Charcos de agua (cada 120m)
            for(let z = 90; z < 1000; z += 120) {
                const puddle = new THREE.Mesh(
                    new THREE.CircleGeometry(0.6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x1a3a4a, roughness: 0.2, metalness: 0.8 })
                );
                puddle.rotation.x = -Math.PI / 2;
                puddle.position.set((Math.random() - 0.5) * 4, 0.01, z);
                scene.add(puddle);
            }
            
            // Escombros en el suelo (cada 100m)
            for(let z = 70; z < 1000; z += 100) {
                for(let i = 0; i < 3; i++) {
                    const debris = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2 + Math.random() * 0.3, 0.1, 0.2 + Math.random() * 0.3),
                        new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 1, metalness: 0 })
                    );
                    debris.position.set((Math.random() - 0.5) * 7, 0.05, z + (Math.random() - 0.5) * 10);
                    debris.rotation.y = Math.random() * Math.PI;
                    scene.add(debris);
                }
            }
            
            // Ventiladores oxidados en el techo (cada 150m)
            for(let z = 100; z < 1000; z += 150) {
                const fanGroup = new THREE.Group();
                
                // Base del ventilador
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.9, metalness: 0.2 })
                );
                fanGroup.add(base);
                
                // 3 aspas
                for(let i = 0; i < 3; i++) {
                    const blade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.05, 0.15),
                        new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8, metalness: 0.1 })
                    );
                    blade.rotation.y = (i * Math.PI * 2) / 3;
                    fanGroup.add(blade);
                }
                
                fanGroup.position.set((Math.random() - 0.5) * 4, 3.8, z);
                fanGroup.userData.speed = 0.01 + Math.random() * 0.02;
                scene.add(fanGroup);
                ceilingFans.push(fanGroup);
            }
        }

        function pickupFlashlight() {
            hasFlashlight = true;
            flashlightOn = true;
            scene.remove(flashlight);
            canInteract = false;
            
            // Mostrar tutorial
            setTimeout(() => showTutorial(), 1000);
            
            // Vibraci√≥n al tomar la linterna
            vibrateGamepad(150, 0.3, 0.3);
            
            // Remover luz de la linterna en la mesa
            scene.children.forEach(child => {
                if(child instanceof THREE.PointLight && child.color.getHex() === 0xffe680) {
                    scene.remove(child);
                }
            });
            
            // Apagar luz de techo inmediatamente (sin fade para evitar lag)
            if(ceilingLight) {
                ceilingLight.intensity = 0;
                ceilingLight.castShadow = false;
            }
        }

        function showLocation(title, subtitle) {
            const locationEl = document.getElementById('location');
            locationEl.querySelector('.location-title').textContent = title;
            locationEl.querySelector('.location-subtitle').textContent = subtitle;
            locationEl.classList.add('show');
            
            setTimeout(() => {
                locationEl.classList.remove('show');
            }, 4000);
        }

        function toggleFlashlight() {
            if(!hasFlashlight) return;
            flashlightOn = !flashlightOn;
            playFlashlightSound();
        }

        function openLore() {
            if(!chest) return;
            
            // Animaci√≥n de apertura del cofre
            const lid = chest.children[1];
            if(lid) {
                let rotation = 0;
                const openInterval = setInterval(() => {
                    rotation += 0.05;
                    lid.rotation.x = -rotation;
                    lid.position.z = Math.sin(rotation) * 0.3;
                    lid.position.y = 0.55 + Math.sin(rotation) * 0.2;
                    
                    if(rotation >= Math.PI / 2) {
                        clearInterval(openInterval);
                    }
                }, 16);
            }
            
            // Mostrar panel de lore despu√©s de la animaci√≥n
            setTimeout(() => {
                document.getElementById('lore').style.display = 'block';
                document.exitPointerLock();
                localStorage.setItem('strangeCompleted', 'true');
            }, 500);
            
            // Vibraci√≥n al abrir el cofre
            vibrateGamepad(300, 0.5, 0.5);
            
            // Remover interacci√≥n
            canInteract = false;
        }

        function closeLore() {
            document.getElementById('lore').style.display = 'none';
        }

        let cinematicPlaying = false;
        
        function showEndSequence() {
            if(cinematicPlaying) return;
            cinematicPlaying = true;
            moveForward = moveBackward = moveLeft = moveRight = false;
            isRunning = false;
            joystickX = 0;
            joystickY = 0;
            
            document.exitPointerLock();
            
            // Posicionar c√°mara justo antes de la puerta mirando hacia ella
            camera.position.z = 2478;
            camera.rotation.x = 0;
            camera.rotation.y = Math.PI;
            
            let exitTime = 0;
            const exitInterval = setInterval(() => {
                exitTime += 16;
                camera.position.z += 0.05;
                if(exitTime >= 2000) {
                    clearInterval(exitInterval);
                    spawnMysteryCharacter();
                }
            }, 16);
        }

        function tripPlayer() {
            tripped = true;
            isRunning = false;
            
            // Reducir velocidad dr√°sticamente
            velocity.multiplyScalar(0.3);
            
            // Vibraci√≥n
            vibrateGamepad(300, 0.8, 0.8);
            
            // Mensaje
            showMonologue('¬°Tropec√©!');
            
            // Recuperarse despu√©s de 1 segundo
            setTimeout(() => {
                tripped = false;
            }, 1000);
        }

        function catchPlayer() {
            // Incrementar contador de muertes
            deathCount++;
            updateDeathCounter();
            
            // Slow motion effect
            let slowMotionTime = 0;
            const slowMotionInterval = setInterval(() => {
                slowMotionTime += 16;
                if(slowMotionTime >= 800) clearInterval(slowMotionInterval);
            }, 32); // Simula slow motion con frames m√°s lentos
            
            // Detener movimiento
            moveForward = moveBackward = moveLeft = moveRight = false;
            velocity.set(0, 0, 0);
            
            // Detener audio de persecuci√≥n
            if(chaseAudio) chaseAudio.pause();
            
            // Vibraci√≥n intensa
            vibrateGamepad(1500, 1.0, 1.0);
            
            // Glitch intenso
            let glitchTime = 0;
            const glitchInterval = setInterval(() => {
                glitchTime += 16;
                applyDistortion(0.9);
                camera.position.x += (Math.random() - 0.5) * 0.3;
                camera.rotation.z += (Math.random() - 0.5) * 0.1;
                renderer.domElement.style.filter = `hue-rotate(${Math.random() * 360}deg) saturate(${Math.random() * 3})`;
                
                if(glitchTime >= 1000) {
                    clearInterval(glitchInterval);
                    renderer.domElement.style.filter = 'none';
                }
            }, 50);
            
            // Pantalla roja
            const redOverlay = document.createElement('div');
            redOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 0, 0, 0.8);
                z-index: 500;
                opacity: 0;
                transition: opacity 0.5s;
            `;
            document.body.appendChild(redOverlay);
            setTimeout(() => redOverlay.style.opacity = '1', 50);
            
            // Mensaje de captura
            showMonologue('¬°TE ATRAP√ì!');
            
            // Animaci√≥n de knockeo m√°s cinematogr√°fica
            setTimeout(() => {
                // Fade a negro
                redOverlay.style.background = 'rgba(0, 0, 0, 1)';
                
                setTimeout(() => {
                    // Teletransportar a 950m
                    camera.position.z = 950;
                    killerPosition = 850;
                    isCaught = false;
                    camera.rotation.z = 0;
                    
                    // Mensaje de despertar
                    showMonologue('¬øQu√©... qu√© pas√≥?');
                    
                    // Fade out del overlay
                    redOverlay.style.opacity = '0';
                    setTimeout(() => redOverlay.remove(), 1000);
                    
                    // Reanudar persecuci√≥n
                    if(chaseAudio) chaseAudio.play().catch(() => {});
                }, 2000);
            }, 1500);
        }

        function updateDeathCounter() {
            const counter = document.getElementById('deathCounter');
            if(counter) {
                counter.textContent = `‚ò†Ô∏è Muertes: ${deathCount}`;
                counter.style.display = 'block';
            }
        }

        function saveProgress() {
            const saveData = {
                position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                rotation: { x: mouseX, y: mouseY },
                hasFlashlight: hasFlashlight,
                flashlightOn: flashlightOn,
                stamina: stamina,
                deathCount: deathCount,
                inStartRoom: inStartRoom,
                doorBroken: doorBroken,
                paintingInteracted: paintingInteracted,
                killerSpawned: killerSpawned,
                ghostEventTriggered: ghostEventTriggered,
                timestamp: Date.now()
            };
            
            localStorage.setItem('deadlyPursuerSave', JSON.stringify(saveData));
            showMonologue(`‚úîÔ∏è Progreso guardado (${Math.floor(Math.max(0, camera.position.z))}m)`);
        }

        function loadProgress() {
            const saveData = localStorage.getItem('deadlyPursuerSave');
            if(!saveData) {
                showMonologue('‚ùå No hay progreso guardado');
                return;
            }
            
            try {
                const data = JSON.parse(saveData);
                
                // Restaurar posici√≥n
                camera.position.set(data.position.x, data.position.y, data.position.z);
                mouseX = data.rotation.x;
                mouseY = data.rotation.y;
                
                // Restaurar estado
                hasFlashlight = data.hasFlashlight;
                flashlightOn = data.flashlightOn;
                stamina = data.stamina;
                deathCount = data.deathCount;
                inStartRoom = data.inStartRoom;
                doorBroken = data.doorBroken;
                paintingInteracted = data.paintingInteracted;
                killerSpawned = data.killerSpawned;
                ghostEventTriggered = data.ghostEventTriggered;
                // Actualizar UI
                updateDeathCounter();
                document.getElementById('distance').textContent = `Distancia: ${Math.floor(Math.max(0, camera.position.z))}m`;
                
                // Remover linterna de la escena si ya la tiene
                if(hasFlashlight && flashlight) {
                    scene.remove(flashlight);
                    flashlight = null;
                }
                
                // Apagar luz de techo si no est√° en habitaci√≥n inicial
                if(!inStartRoom && ceilingLight) {
                    ceilingLight.intensity = 0;
                    scene.children.find(c => c instanceof THREE.AmbientLight).intensity = 0;
                }
                
                // Remover puerta misteriosa si ya fue rota
                if(doorBroken && mysteryDoor) {
                    scene.remove(mysteryDoor);
                    mysteryDoor = null;
                }
                
                // Cargar zonas seg√∫n posici√≥n
                if(camera.position.z >= 50 && !hallwayLoaded) {
                    loadHallwayZone();
                }
                if(camera.position.z >= 900 && !grassZoneLoaded) {
                    loadGrassZone();
                }
                
                // Si killerSpawned es true pero est√°s antes de 1000m, resetear
                if(killerSpawned && camera.position.z < 1000) {
                    killerSpawned = false;
                    killerChasing = false;
                }
                
                // Actualizar mon√≥logo seg√∫n distancia
                const distance = Math.floor(camera.position.z);
                while(currentMonologue < monologues.length && distance >= monologues[currentMonologue].dist) {
                    currentMonologue++;
                }
                
                showMonologue('‚úîÔ∏è Progreso cargado');
                toggleSettings();
            } catch(e) {
                showMonologue('‚ùå Error al cargar');
                console.error('Error cargando progreso:', e);
            }
        }

        function startRain() {
            // Crear part√≠culas de lluvia
            for(let i = 0; i < 200; i++) {
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0, 0, 0,
                    0, -0.3, 0
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                const material = new THREE.LineBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
                const rain = new THREE.Line(geometry, material);
                
                rain.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 10 + 5,
                    camera.position.z + (Math.random() - 0.5) * 50
                );
                
                rain.userData.velocity = Math.random() * 0.3 + 0.2;
                scene.add(rain);
                rainParticles.push(rain);
            }
            
            // Audio de lluvia
            if(rainAudio) rainAudio.play().catch(() => {});
            
            showMonologue('Est√° lloviendo...');
        }

        function updateRain() {
            for(let rain of rainParticles) {
                rain.position.y -= rain.userData.velocity;
                
                if(rain.position.y < 0) {
                    rain.position.y = Math.random() * 10 + 5;
                    rain.position.z = camera.position.z + (Math.random() - 0.5) * 50;
                }
            }
        }

        function stopRain() {
            for(let rain of rainParticles) {
                scene.remove(rain);
            }
            rainParticles = [];
            
            if(rainAudio) rainAudio.pause();
        }

        function showProximamente() {
            // Cambiar perspectiva de c√°mara
            const originalRotX = camera.rotation.x;
            const originalRotY = camera.rotation.y;
            camera.rotation.x = -0.3;
            camera.rotation.y = 0;
            
            // Animaci√≥n de salir por la puerta
            let exitTime = 0;
            const exitInterval = setInterval(() => {
                exitTime += 16;
                camera.position.z += 0.05;
                if(exitTime >= 2000) {
                    clearInterval(exitInterval);
                    spawnMysteryCharacter();
                }
            }, 16);
        }
        
        function spawnMysteryCharacter() {
            // Crear personaje misterioso enfrente
            const character = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.3, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0x330033, emissiveIntensity: 0.5 })
            );
            character.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, emissive: 0x660066, emissiveIntensity: 0.7 })
            );
            head.position.y = 1.3;
            character.add(head);
            
            const eye1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff00ff })
            );
            eye1.position.set(-0.2, 1.4, 0.4);
            character.add(eye1);
            
            const eye2 = eye1.clone();
            eye2.position.set(0.2, 1.4, 0.4);
            character.add(eye2);
            
            // Luz para iluminar al personaje
            const charLight = new THREE.PointLight(0xff00ff, 1.5, 10);
            charLight.position.set(0, 2, 0);
            character.add(charLight);
            
            character.position.set(0, 0, camera.position.z + 5);
            character.rotation.y = Math.PI;
            scene.add(character);
            
            // Mostrar mensajes uno por uno
            let msgIndex = 0;
            let currentBubble = null;
            const showNextMessage = () => {
                if(msgIndex < endMessages.length) {
                    if(currentBubble) character.remove(currentBubble);
                    currentBubble = createSpeechBubble(endMessages[msgIndex]);
                    currentBubble.position.set(0, 2.5, 0);
                    character.add(currentBubble);
                    msgIndex++;
                    setTimeout(showNextMessage, 3000);
                } else {
                    if(currentBubble) character.remove(currentBubble);
                    // Despu√©s del √∫ltimo mensaje, romper el suelo
                    setTimeout(() => breakFloor(character), 1000);
                }
            };
            showNextMessage();
        }
        
        function createSpeechBubble(text) {
            const bubble = new THREE.Group();
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.roundRect(10, 10, 492, 108, 15);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const words = text.split(' ');
            let lines = [], currentLine = '';
            words.forEach(word => {
                const testLine = currentLine + word + ' ';
                if(ctx.measureText(testLine).width > 460 && currentLine) {
                    lines.push(currentLine);
                    currentLine = word + ' ';
                } else currentLine = testLine;
            });
            lines.push(currentLine);
            lines.forEach((line, i) => ctx.fillText(line.trim(), 256, 64 - ((lines.length - 1) * 15) + i * 30));
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 1), new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, depthTest: false }));
            plane.renderOrder = 999;
            bubble.add(plane);
            return bubble;
        }
        
        function breakFloor(character) {
            showMonologue('¬øQu√©...? ¬°EL SUELO!');
            showMonologue('¬øQu√©...? ¬°EL SUELO!');
            vibrateGamepad(500, 0.8, 0.8);
            
            // Shake de c√°mara intenso
            const originalY = camera.position.y;
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                camera.position.y = originalY + Math.sin(shakeTime * 80) * 0.15;
                camera.position.x += (Math.random() - 0.5) * 0.1;
                shakeTime += 0.016;
                if(shakeTime > 1.5) {
                    clearInterval(shakeInterval);
                    camera.position.y = originalY;
                }
            }, 16);
            
            // Remover suelo visible
            platforms.forEach(p => scene.remove(p));
            
            // Crear m√°s fragmentos del suelo con part√≠culas de polvo
            const floorFragments = [];
            for(let i = 0; i < 40; i++) {
                const fragment = new THREE.Mesh(
                    new THREE.BoxGeometry(Math.random() + 0.5, 0.1, Math.random() + 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                );
                fragment.position.set(
                    (Math.random() - 0.5) * 4,
                    0,
                    camera.position.z + (Math.random() - 0.5) * 3
                );
                fragment.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    -Math.random() * 0.08,
                    (Math.random() - 0.5) * 0.15
                );
                scene.add(fragment);
                floorFragments.push(fragment);
            }
            
            // Part√≠culas de polvo
            for(let i = 0; i < 30; i++) {
                const dust = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 4, 4),
                    new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.6 })
                );
                dust.position.set(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 0.5,
                    camera.position.z + (Math.random() - 0.5) * 4
                );
                dust.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    Math.random() * 0.1 + 0.05,
                    (Math.random() - 0.5) * 0.05
                );
                scene.add(dust);
                floorFragments.push(dust);
            }
            
            // Animar fragmentos cayendo
            let breakTime = 0;
            const breakInterval = setInterval(() => {
                breakTime += 16;
                floorFragments.forEach(frag => {
                    frag.position.add(frag.userData.velocity);
                    frag.userData.velocity.y -= 0.01;
                    frag.rotation.x += 0.05;
                    frag.rotation.z += 0.03;
                    if(frag.material.transparent) frag.material.opacity -= 0.01;
                });
                
                if(breakTime >= 1500) {
                    clearInterval(breakInterval);
                    floorFragments.forEach(f => scene.remove(f));
                    startFalling(character);
                }
            }, 16);
        }
        
        function startFalling(character) {
            // Desbloquear Cap√≠tulo 2 al completar Cap√≠tulo 1
            localStorage.setItem('chapter2Unlocked', 'true');
            
            let fallTime = 0;
            const fallDuration = 3500;
            const initialY = camera.position.y;
            
            // Vi√±eta que se intensifica
            const vignetteEl = document.getElementById('vignette');
            
            const fallInterval = setInterval(() => {
                fallTime += 16;
                const progress = fallTime / fallDuration;
                
                // Ca√≠da con aceleraci√≥n
                playerY = initialY - (progress * progress * 60);
                camera.position.y = playerY;
                
                // Rotaci√≥n m√°s dram√°tica
                camera.rotation.z = Math.sin(progress * Math.PI * 3) * 0.5;
                camera.rotation.x = progress * Math.PI * 1.5;
                
                // Shake durante la ca√≠da
                camera.position.x += (Math.random() - 0.5) * 0.2 * progress;
                
                // Vi√±eta se intensifica
                if(vignetteEl) vignetteEl.style.opacity = progress * 0.9;
                
                if(character) character.position.y -= 0.4;
                
                // Vibraci√≥n m√°s frecuente
                if(fallTime % 150 === 0) vibrateGamepad(100, 0.6 * progress, 0.6 * progress);
                
                // Flash blanco al impactar
                if(fallTime >= fallDuration - 100 && fallTime < fallDuration - 80) {
                    renderer.domElement.style.filter = 'brightness(3)';
                }
                
                if(fallTime >= fallDuration) {
                    clearInterval(fallInterval);
                    if(character) scene.remove(character);
                    renderer.domElement.style.filter = 'brightness(1)';
                    if(vignetteEl) vignetteEl.style.opacity = '0';
                    
                    const blackOverlay = document.createElement('div');
                    blackOverlay.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0, 0, 0, 1); z-index: 1000; opacity: 0;
                        transition: opacity 0.5s;
                    `;
                    document.body.appendChild(blackOverlay);
                    setTimeout(() => blackOverlay.style.opacity = '1', 50);
                    
                    vibrateGamepad(1000, 1.0, 1.0);
                    showMonologue('*GOLPE FUERTE*');
                    showMonologue('üîì CAP√çTULO 2 DESBLOQUEADO');
                    
                    setTimeout(() => {
                        chapter2.start();
                        blackOverlay.style.opacity = '0';
                        setTimeout(() => blackOverlay.remove(), 2000);
                    }, 2000);
                }
            }, 16);
        }

        init();
    </script>
</body>
</html>
